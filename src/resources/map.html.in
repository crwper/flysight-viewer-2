<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>FlySight Map</title>
<style>
html, body, #map {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
}
#error {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: sans-serif;
    font-size: 14px;
    color: #666;
    text-align: center;
    padding: 20px;
}
</style>
<!-- QWebChannel JS (bundled with Qt) -->
<script src="qrc:///qtwebchannel/qwebchannel.js"></script>
</head>
<body>
<div id="map"></div>
<div id="error">
    <p><strong>Google Maps API key not configured.</strong></p>
    <p>Set the GOOGLE_MAPS_API_KEY CMake variable to enable the map.</p>
</div>
<script>
// ===========================================================================
// Task 4.1: API Key Gating
// ===========================================================================
var API_KEY = "@GOOGLE_MAPS_API_KEY@";

if (!API_KEY || API_KEY === "") {
    document.getElementById("error").style.display = "block";
    document.getElementById("map").style.display = "none";
} else {
    // Dynamically load Google Maps API
    var script = document.createElement("script");
    script.src = "https://maps.googleapis.com/maps/api/js?key=" +
                 encodeURIComponent(API_KEY) + "&callback=onMapsApiReady";
    script.async = true;
    script.defer = true;
    document.head.appendChild(script);
}

// ===========================================================================
// Task 4.3: Map Type Index Mapping
// ===========================================================================
var MAP_TYPE_IDS = null; // initialized after Maps API loads

function mapTypeIdToIndex(typeId) {
    if (!MAP_TYPE_IDS) return 0;
    for (var i = 0; i < MAP_TYPE_IDS.length; i++) {
        if (MAP_TYPE_IDS[i] === typeId) return i;
    }
    return 0;
}

function indexToMapTypeId(index) {
    if (!MAP_TYPE_IDS || index < 0 || index >= MAP_TYPE_IDS.length)
        return "roadmap";
    return MAP_TYPE_IDS[index];
}

// ===========================================================================
// Task 4.4: Color Format Conversion (#AARRGGBB -> CSS)
// ===========================================================================
function qtColorToCSS(qtColor) {
    if (!qtColor || qtColor.length < 7) return "rgba(0,0,0,1)";
    // Standard 7-char hex (#RRGGBB) -- pass through
    if (qtColor.length === 7) return qtColor;
    // Qt HexArgb format: #AARRGGBB
    var a = parseInt(qtColor.substring(1, 3), 16) / 255.0;
    var r = parseInt(qtColor.substring(3, 5), 16);
    var g = parseInt(qtColor.substring(5, 7), 16);
    var b = parseInt(qtColor.substring(7, 9), 16);
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
}

function qtColorOpacity(qtColor) {
    if (!qtColor || qtColor.length < 9) return 1.0;
    return parseInt(qtColor.substring(1, 3), 16) / 255.0;
}

function qtColorRGB(qtColor) {
    if (!qtColor || qtColor.length < 9) return qtColor || "#000000";
    return "#" + qtColor.substring(3, 9);
}

// ===========================================================================
// Global state
// ===========================================================================
var map = null;
var bridge = null;

// Track polylines and data (Task 4.5)
var polylines = new Map();
var trackData = new Map();
var trackColors = new Map();   // sessionId -> "#AARRGGBB" (Qt HexArgb)

// Cursor dot markers (Task 4.6)
var cursorMarkers = new Map();

// JS hover marker (Phase 1: instant hover)
var hoverMarker = null;        // google.maps.Marker for instant JS hover

// Preference defaults
var prefLineThickness = 3.0;
var prefTrackOpacity = 0.85;
var prefMarkerSize = 10;

// DPI compensation: QWebEngineView applies setZoomFactor(1/dpr) to fix
// oversized Google Maps controls.  After that, window.devicePixelRatio
// reports 1.0, so C++ injects the true native DPR as window._nativeDpr.
// Multiply our own drawing sizes by this value so tracks and markers
// remain at their intended physical size.
var dpiScale = window._nativeDpr || 1.0;

// Hover state (Task 4.7)
var HOVER_THRESHOLD_PX = 10;
var HOVER_MIN_MOVE_PX = 2;
var HOVER_TIME_EPSILON_SEC = 0.02;
var hoverSessionId = "";
var hoverUtcSeconds = NaN;
var lastMouseX = -1;
var lastMouseY = -1;
var pendingHoverRAF = false;
var pendingMouseX = -1;
var pendingMouseY = -1;

// Timer-based hover coalescing (Phase 2: ~30 Hz throttle)
var HOVER_SEND_INTERVAL_MS = 33;  // ~30 Hz
var hoverSendTimer = null;        // setInterval timer ID, null when idle
var pendingHoverSessionId = "";   // latest computed sessionId (buffered)
var pendingHoverUtcSeconds = NaN; // latest computed utcSeconds (buffered)
var pendingHoverDirty = false;    // true when buffer has unsent data

// Pixel cache (Phase 3: pre-projected track vertices)
var pixelCache = null;   // Map: sessionId -> { xs: Float64Array, ys: Float64Array, ts: Float64Array, lats: Float64Array, lons: Float64Array, count: number }
var cacheValid = false;  // true when pixelCache matches current projection

// Spatial grid index (Phase 3: uniform grid for O(k) hover lookup)
var gridCellSize = 0;    // pixel size of each grid cell
var gridCols = 0;        // number of columns in the grid
var gridRows = 0;        // number of rows in the grid
var gridOffsetX = 0;     // pixel X offset (min X of all projected points)
var gridOffsetY = 0;     // pixel Y offset (min Y of all projected points)
var gridCells = null;    // flat array of arrays: gridCells[row * gridCols + col] = [{sessionId, segIdx}, ...]

// Track draw order and sticky session (Phase 3: tie-breaking)
var trackDrawOrder = new Map();  // sessionId -> integer draw index (higher = on top)
var lastHoveredSessionId = "";   // sessionId of the most recently hovered session

// OverlayView for pixel projection (Task 4.7)
var projectionOverlay = null;

// ===========================================================================
// Task 4.3: Map Initialization
// ===========================================================================
function onMapsApiReady() {
    MAP_TYPE_IDS = [
        google.maps.MapTypeId.ROADMAP,    // 0
        google.maps.MapTypeId.SATELLITE,  // 1
        google.maps.MapTypeId.TERRAIN,    // 2
        google.maps.MapTypeId.HYBRID      // 3
    ];

    map = new google.maps.Map(document.getElementById("map"), {
        zoom: 12,
        center: { lat: 0, lng: 0 },
        disableDefaultUI: true,
        zoomControl: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
            style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
            position: google.maps.ControlPosition.TOP_RIGHT
        },
        mapTypeId: google.maps.MapTypeId.ROADMAP
    });

    // Report map type changes back to C++
    map.addListener("maptypeid_changed", function() {
        if (!bridge) return;
        bridge.onMapTypeChanged(mapTypeIdToIndex(map.getMapTypeId()));
    });

    // Set up projection overlay for hover pixel conversion
    initProjectionOverlay();

    // Attach mouse listeners for hover detection
    initHoverListeners();

    // Initialize the QWebChannel bridge
    initBridge();
}

// ===========================================================================
// Task 4.2: QWebChannel Initialization and Bridge Connection
// ===========================================================================
function initBridge() {
    new QWebChannel(qt.webChannelTransport, function(channel) {
        bridge = channel.objects.bridge;

        // Connect C++ -> JS signals
        bridge.tracksChanged.connect(onTracksChanged);
        bridge.cursorDotsChanged.connect(onCursorDotsChanged);
        bridge.fitBounds.connect(onFitBounds);
        bridge.preferenceChanged.connect(onPreferenceChanged);

        // Request all current data now that JS is ready
        bridge.requestInitialData();
    });
}

// ===========================================================================
// Task 4.5: Track Polylines
// ===========================================================================
function onTracksChanged(tracks) {
    // Invalidate pixel cache and grid before clearing data
    cacheValid = false;
    pixelCache = null;
    gridCells = null;

    // Clean up hover marker, timer, and reset hover state before clearing data
    hideHoverMarker();
    hoverSessionId = "";
    hoverUtcSeconds = NaN;
    pendingHoverDirty = false;
    if (hoverSendTimer !== null) {
        clearInterval(hoverSendTimer);
        hoverSendTimer = null;
    }

    // Remove existing polylines
    polylines.forEach(function(pl) { pl.setMap(null); });
    polylines.clear();
    trackData.clear();
    trackColors.clear();
    trackDrawOrder.clear();

    if (!tracks) return;

    for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        trackData.set(track.sessionId, track.points);
        trackColors.set(track.sessionId, track.color);
        trackDrawOrder.set(track.sessionId, i);

        var path = [];
        for (var j = 0; j < track.points.length; j++) {
            path.push({ lat: track.points[j].lat, lng: track.points[j].lon });
        }

        var polyline = new google.maps.Polyline({
            path: path,
            strokeColor: qtColorRGB(track.color),
            strokeOpacity: prefTrackOpacity,
            strokeWeight: prefLineThickness * dpiScale,
            map: map,
            zIndex: 10
        });
        polylines.set(track.sessionId, polyline);
    }

    // Build pixel cache and spatial grid for the new track data
    rebuildPixelCache();
}

// ===========================================================================
// Task 4.6: Cursor Dot Markers
// ===========================================================================
function onCursorDotsChanged(dots) {
    // Build a set of session IDs present in the new data
    var incoming = new Set();

    if (dots) {
        for (var i = 0; i < dots.length; i++) {
            var dot = dots[i];

            // Skip â€” JS hover marker is handling this session
            if (hoverSessionId !== "" && dot.sessionId === hoverSessionId) {
                continue;
            }

            incoming.add(dot.sessionId);

            var existing = cursorMarkers.get(dot.sessionId);
            if (existing) {
                // Update position of existing marker (no flicker)
                existing.setPosition({ lat: dot.lat, lng: dot.lon });
            } else {
                // Create marker for new session
                var marker = new google.maps.Marker({
                    position: { lat: dot.lat, lng: dot.lon },
                    map: map,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: qtColorRGB(dot.color),
                        fillOpacity: 1.0,
                        strokeColor: "#ffffff",
                        strokeWeight: 2 * dpiScale,
                        scale: (prefMarkerSize / 2) * dpiScale
                    },
                    zIndex: 20,
                    clickable: false
                });
                cursorMarkers.set(dot.sessionId, marker);
            }
        }
    }

    // Remove markers for sessions no longer present
    cursorMarkers.forEach(function(marker, sessionId) {
        if (!incoming.has(sessionId)) {
            marker.setMap(null);
            cursorMarkers.delete(sessionId);
        }
    });
}

// ===========================================================================
// Task 4.7: Hover Detection on Polylines
// ===========================================================================

/**
 * Show (or update) the JS hover marker at the given interpolated position.
 * Uses the session's track color for the marker fill.
 */
function showHoverMarker(lat, lon, sessionId) {
    var color = trackColors.get(sessionId) || "#FF4285F4";

    if (hoverMarker === null) {
        // Create a new marker (same style as cursor dots but zIndex 30)
        hoverMarker = new google.maps.Marker({
            position: { lat: lat, lng: lon },
            map: map,
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                fillColor: qtColorRGB(color),
                fillOpacity: 1.0,
                strokeColor: "#ffffff",
                strokeWeight: 2 * dpiScale,
                scale: (prefMarkerSize / 2) * dpiScale
            },
            zIndex: 30,
            clickable: false
        });
    } else {
        hoverMarker.setPosition({ lat: lat, lng: lon });
        // Update icon color if the session changed
        if (sessionId !== hoverSessionId) {
            var icon = hoverMarker.getIcon();
            if (icon) {
                icon.fillColor = qtColorRGB(color);
                hoverMarker.setIcon(icon);
            }
        }
    }
}

/**
 * Hide and destroy the JS hover marker.
 * Safe to call multiple times (idempotent).
 */
function hideHoverMarker() {
    if (hoverMarker !== null) {
        hoverMarker.setMap(null);
        hoverMarker = null;
    }
}

/**
 * Initialize a transparent OverlayView so we can access the
 * MapCanvasProjection for fromLatLngToContainerPixel().
 */
function initProjectionOverlay() {
    var OverlayClass = function() {};
    OverlayClass.prototype = new google.maps.OverlayView();
    OverlayClass.prototype.onAdd = function() {};
    OverlayClass.prototype.onRemove = function() {};
    OverlayClass.prototype.draw = function() {};

    projectionOverlay = new OverlayClass();
    projectionOverlay.setMap(map);
}

/**
 * Convert a LatLng to container pixel coordinates using the overlay projection.
 * Returns {x, y} or null if projection not ready.
 */
function latLngToPixel(lat, lon) {
    if (!projectionOverlay) return null;
    var proj = projectionOverlay.getProjection();
    if (!proj) return null;
    var pt = proj.fromLatLngToContainerPixel(
        new google.maps.LatLng(lat, lon)
    );
    return pt ? { x: pt.x, y: pt.y } : null;
}

/**
 * Squared distance from point P to segment AB, plus parametric u.
 * Ported faithfully from MapDock.qml _distPointToSegment2.
 */
function distPointToSegment2(px, py, ax, ay, bx, by) {
    var abx = bx - ax, aby = by - ay;
    var apx = px - ax, apy = py - ay;
    var denom = abx * abx + aby * aby;
    var u = 0.0;
    if (denom > 1e-9)
        u = (apx * abx + apy * aby) / denom;
    if (u < 0) u = 0;
    else if (u > 1) u = 1;
    var cx = ax + u * abx, cy = ay + u * aby;
    var dx = px - cx, dy = py - cy;
    return { dist2: dx * dx + dy * dy, u: u };
}

/**
 * Rebuild the pixel cache by pre-projecting all track vertices to
 * container pixel coordinates.  Called from onTracksChanged() and
 * the map 'idle' event.  After a successful build, calls rebuildGrid()
 * to populate the spatial index.
 */
function rebuildPixelCache() {
    var newCache = new Map();

    var failed = false;
    trackData.forEach(function(points, sessionId) {
        if (failed) return;
        if (!points || points.length === 0) return;

        var count = points.length;
        var xs = new Float64Array(count);
        var ys = new Float64Array(count);
        var ts = new Float64Array(count);
        var lats = new Float64Array(count);
        var lons = new Float64Array(count);

        for (var i = 0; i < count; i++) {
            var pt = latLngToPixel(points[i].lat, points[i].lon);
            if (!pt) {
                // Projection not ready -- abort the entire build
                failed = true;
                return;
            }
            xs[i] = pt.x;
            ys[i] = pt.y;
            ts[i] = points[i].t !== undefined ? points[i].t : NaN;
            lats[i] = points[i].lat;
            lons[i] = points[i].lon;
        }

        newCache.set(sessionId, { xs: xs, ys: ys, ts: ts, lats: lats, lons: lons, count: count });
    });

    if (failed) {
        cacheValid = false;
        pixelCache = null;
        gridCells = null;
        return;
    }

    pixelCache = newCache;
    cacheValid = true;
    rebuildGrid();
}

/**
 * Build a uniform spatial grid index over all cached pixel-space segments.
 * Called at the end of rebuildPixelCache() after the cache is successfully
 * built.  Each grid cell stores references to segments whose pixel bounding
 * box overlaps that cell, enabling O(k) hover lookup via a 3x3 neighborhood
 * scan.
 */
function rebuildGrid() {
    gridCells = null;
    gridCellSize = 2 * HOVER_THRESHOLD_PX * dpiScale;
    if (gridCellSize <= 0) return;

    // Compute bounding box of all projected pixel coordinates
    var minX = Infinity, maxX = -Infinity;
    var minY = Infinity, maxY = -Infinity;
    var hasPoints = false;

    pixelCache.forEach(function(entry) {
        var xs = entry.xs, ys = entry.ys, count = entry.count;
        for (var i = 0; i < count; i++) {
            var x = xs[i], y = ys[i];
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
            hasPoints = true;
        }
    });

    if (!hasPoints) return;

    gridOffsetX = Math.floor(minX);
    gridOffsetY = Math.floor(minY);
    gridCols = Math.ceil((maxX - gridOffsetX) / gridCellSize) + 1;
    gridRows = Math.ceil((maxY - gridOffsetY) / gridCellSize) + 1;

    // Safety cap: prevent degenerate grid sizes
    if (gridCols * gridRows > 100000) {
        gridCells = null;
        return;
    }

    // Allocate grid with null entries (lazily populated)
    gridCells = new Array(gridRows * gridCols);
    for (var k = 0; k < gridCells.length; k++) {
        gridCells[k] = null;
    }

    // Insert each segment into all grid cells its pixel bbox overlaps
    pixelCache.forEach(function(entry, sessionId) {
        var xs = entry.xs, ys = entry.ys, count = entry.count;
        for (var i = 0; i < count - 1; i++) {
            var cMin = Math.floor((Math.min(xs[i], xs[i + 1]) - gridOffsetX) / gridCellSize);
            var cMax = Math.floor((Math.max(xs[i], xs[i + 1]) - gridOffsetX) / gridCellSize);
            var rMin = Math.floor((Math.min(ys[i], ys[i + 1]) - gridOffsetY) / gridCellSize);
            var rMax = Math.floor((Math.max(ys[i], ys[i + 1]) - gridOffsetY) / gridCellSize);

            // Clamp to grid bounds
            if (cMin < 0) cMin = 0;
            if (cMax >= gridCols) cMax = gridCols - 1;
            if (rMin < 0) rMin = 0;
            if (rMax >= gridRows) rMax = gridRows - 1;

            for (var row = rMin; row <= rMax; row++) {
                for (var col = cMin; col <= cMax; col++) {
                    var idx = row * gridCols + col;
                    if (gridCells[idx] === null) {
                        gridCells[idx] = [];
                    }
                    gridCells[idx].push({ sessionId: sessionId, segIdx: i });
                }
            }
        }
    });
}

/**
 * Tie-breaking helper: determine whether a candidate segment should replace
 * the current best hover match.  Uses distance comparison with a tie-break
 * zone where sticky session and draw order preferences apply.
 */
function shouldReplaceHoverCandidate(candidateDist2, candidateSessionId, bestDist2, bestSessionId) {
    var TIE_BREAK_PX = 3 * dpiScale;
    var TIE_BREAK_PX2 = TIE_BREAK_PX * TIE_BREAK_PX;

    if (candidateDist2 < bestDist2 - TIE_BREAK_PX2) {
        return true;  // candidate is clearly closer
    }
    if (candidateDist2 < bestDist2 + TIE_BREAK_PX2) {
        // Within tie threshold: prefer sticky session, then higher draw order
        var candidateOrder = trackDrawOrder.get(candidateSessionId) || 0;
        var bestOrder = trackDrawOrder.get(bestSessionId) || 0;

        if (candidateSessionId === lastHoveredSessionId && bestSessionId !== lastHoveredSessionId) {
            return true;   // sticky session wins
        } else if (bestSessionId === lastHoveredSessionId && candidateSessionId !== lastHoveredSessionId) {
            return false;  // current best is sticky, keep it
        } else if (candidateOrder > bestOrder) {
            return true;   // higher draw order wins (drawn on top)
        }
    }
    return false;
}

/**
 * Perform the hover hit-test at container pixel (mx, my).
 */
function updateHoverAt(mx, my) {
    if (!bridge) return;

    var thr = HOVER_THRESHOLD_PX * dpiScale;
    var thr2 = thr * thr;
    var bestDist2 = thr2 + 1;
    var bestSessionId = "";
    var bestUtc = NaN;
    var bestLat = NaN;
    var bestLon = NaN;

    if (cacheValid && gridCells !== null) {
        // Fast path: grid-indexed O(k) lookup using pre-projected pixel cache
        var col = Math.floor((mx - gridOffsetX) / gridCellSize);
        var row = Math.floor((my - gridOffsetY) / gridCellSize);

        // Scan the 3x3 neighborhood around the cursor's grid cell
        var rStart = Math.max(0, row - 1);
        var rEnd = Math.min(gridRows - 1, row + 1);
        var cStart = Math.max(0, col - 1);
        var cEnd = Math.min(gridCols - 1, col + 1);

        for (var gr = rStart; gr <= rEnd; gr++) {
            for (var gc = cStart; gc <= cEnd; gc++) {
                var cell = gridCells[gr * gridCols + gc];
                if (cell === null) continue;

                for (var ci = 0; ci < cell.length; ci++) {
                    var ref = cell[ci];
                    var entry = pixelCache.get(ref.sessionId);
                    if (!entry) continue;

                    var segIdx = ref.segIdx;
                    var r = distPointToSegment2(mx, my,
                        entry.xs[segIdx], entry.ys[segIdx],
                        entry.xs[segIdx + 1], entry.ys[segIdx + 1]);

                    if (bestSessionId === "" || shouldReplaceHoverCandidate(r.dist2, ref.sessionId, bestDist2, bestSessionId)) {
                        bestDist2 = r.dist2;
                        bestSessionId = ref.sessionId;
                        bestUtc = entry.ts[segIdx] + r.u * (entry.ts[segIdx + 1] - entry.ts[segIdx]);
                        bestLat = entry.lats[segIdx] + r.u * (entry.lats[segIdx + 1] - entry.lats[segIdx]);
                        bestLon = entry.lons[segIdx] + r.u * (entry.lons[segIdx + 1] - entry.lons[segIdx]);
                    }
                }
            }
        }
    } else {
        // Fallback path: brute-force O(N) iteration with per-vertex latLngToPixel()
        trackData.forEach(function(points, sessionId) {
            if (!points || points.length < 2) return;

            for (var i = 0; i < points.length - 1; i++) {
                var p0 = points[i];
                var p1 = points[i + 1];

                if (p0.t === undefined || p1.t === undefined) continue;

                var A = latLngToPixel(p0.lat, p0.lon);
                var B = latLngToPixel(p1.lat, p1.lon);
                if (!A || !B) continue;

                var r = distPointToSegment2(mx, my, A.x, A.y, B.x, B.y);

                if (bestSessionId === "" || shouldReplaceHoverCandidate(r.dist2, sessionId, bestDist2, bestSessionId)) {
                    bestDist2 = r.dist2;
                    bestSessionId = sessionId;
                    bestUtc = p0.t + r.u * (p1.t - p0.t);
                    bestLat = p0.lat + r.u * (p1.lat - p0.lat);
                    bestLon = p0.lon + r.u * (p1.lon - p0.lon);
                }
            }
        });
    }

    if (bestSessionId !== "" && bestDist2 <= thr2 && !isNaN(bestUtc)) {
        showHoverMarker(bestLat, bestLon, bestSessionId);
        setMapHover(bestSessionId, bestUtc);
    } else {
        hideHoverMarker();
        clearMapHover();
    }
}

/**
 * Set hover with epsilon pre-filter and timer-based ~30 Hz coalescing.
 * Buffers the latest value and sends via flushHover() at most every
 * HOVER_SEND_INTERVAL_MS milliseconds.  The very first event after idle
 * is sent immediately (zero latency).
 */
function setMapHover(sessionId, utcSeconds) {
    if (!bridge) return;

    // Epsilon pre-filter: skip if value is effectively unchanged
    var sessionChanged = (sessionId !== hoverSessionId);
    var timeChanged = sessionChanged
                   || isNaN(hoverUtcSeconds)
                   || Math.abs(utcSeconds - hoverUtcSeconds) > HOVER_TIME_EPSILON_SEC;

    if (!timeChanged) return;

    // Update dedup state so clearMapHover() knows hover is active
    hoverSessionId = sessionId;
    hoverUtcSeconds = utcSeconds;
    lastHoveredSessionId = sessionId;

    // Buffer the latest values for the next flush
    pendingHoverSessionId = sessionId;
    pendingHoverUtcSeconds = utcSeconds;
    pendingHoverDirty = true;

    // If no send loop is active, flush immediately and start the timer
    if (hoverSendTimer === null) {
        flushHover();
        hoverSendTimer = setInterval(flushHover, HOVER_SEND_INTERVAL_MS);
    }
}

/**
 * Send the most recent buffered hover value to C++.
 * If nothing new has been buffered since the last flush, stop the timer.
 */
function flushHover() {
    if (!pendingHoverDirty) {
        // Nothing new since last flush -- stop the timer
        clearInterval(hoverSendTimer);
        hoverSendTimer = null;
        return;
    }
    pendingHoverDirty = false;
    if (bridge) {
        bridge.onMapHover(pendingHoverSessionId, pendingHoverUtcSeconds);
    }
}

/**
 * Clear hover state.  Sends bridge.onMapHoverClear() immediately (no
 * throttling) so the hover clears responsively when the cursor leaves.
 */
function clearMapHover() {
    hideHoverMarker();
    if (hoverSessionId === "" && isNaN(hoverUtcSeconds)) return;

    hoverSessionId = "";
    hoverUtcSeconds = NaN;
    pendingHoverDirty = false;

    if (hoverSendTimer !== null) {
        clearInterval(hoverSendTimer);
        hoverSendTimer = null;
    }

    if (bridge) {
        bridge.onMapHoverClear();
    }
}

/**
 * Attach mouse listeners for hover detection on the map div.
 */
function initHoverListeners() {
    var mapDiv = map.getDiv();

    mapDiv.addEventListener("mousemove", function(e) {
        var rect = mapDiv.getBoundingClientRect();
        pendingMouseX = e.clientX - rect.left;
        pendingMouseY = e.clientY - rect.top;

        if (!pendingHoverRAF) {
            pendingHoverRAF = true;
            requestAnimationFrame(function() {
                pendingHoverRAF = false;

                // Minimum movement filter
                var dx = pendingMouseX - lastMouseX;
                var dy = pendingMouseY - lastMouseY;
                var min2 = HOVER_MIN_MOVE_PX * HOVER_MIN_MOVE_PX;
                if ((dx * dx + dy * dy) < min2) return;

                lastMouseX = pendingMouseX;
                lastMouseY = pendingMouseY;
                updateHoverAt(pendingMouseX, pendingMouseY);
            });
        }
    });

    mapDiv.addEventListener("mouseleave", function() {
        pendingMouseX = -1;
        pendingMouseY = -1;
        lastMouseX = -1;
        lastMouseY = -1;
        clearMapHover();
    });

    // Invalidate pixel cache and force hover recalculation on view changes
    map.addListener("zoom_changed", function() {
        cacheValid = false;
        forceHoverRecalc();
    });
    map.addListener("center_changed", function() {
        cacheValid = false;
        forceHoverRecalc();
    });

    // Rebuild pixel cache and grid after the map finishes rendering
    map.addListener("idle", function() {
        rebuildPixelCache();
        forceHoverRecalc();
    });
}

/**
 * Force a hover recalculation at the last known mouse position
 * (e.g. after zoom/pan changes the projection).
 */
function forceHoverRecalc() {
    if (pendingMouseX < 0 || pendingMouseY < 0) return;
    // Reset last processed position to force recalculation
    lastMouseX = -1;
    lastMouseY = -1;
    if (!pendingHoverRAF) {
        pendingHoverRAF = true;
        requestAnimationFrame(function() {
            pendingHoverRAF = false;
            lastMouseX = pendingMouseX;
            lastMouseY = pendingMouseY;
            updateHoverAt(pendingMouseX, pendingMouseY);
        });
    }
}

// ===========================================================================
// Task 4.8: Fit-to-Bounds
// ===========================================================================
function onFitBounds(south, west, north, east) {
    if (!map) return;
    map.fitBounds(
        new google.maps.LatLngBounds(
            { lat: south, lng: west },
            { lat: north, lng: east }
        ),
        40 // padding in pixels
    );
}

// ===========================================================================
// Task 4.9: Preference Reactivity
// ===========================================================================
function onPreferenceChanged(key, value) {
    if (key === "map/lineThickness") {
        prefLineThickness = value;
        polylines.forEach(function(pl) {
            pl.setOptions({ strokeWeight: value * dpiScale });
        });
    } else if (key === "map/trackOpacity") {
        prefTrackOpacity = value;
        polylines.forEach(function(pl) {
            pl.setOptions({ strokeOpacity: value });
        });
    } else if (key === "map/markerSize") {
        prefMarkerSize = value;
        cursorMarkers.forEach(function(marker) {
            var icon = marker.getIcon();
            if (icon) {
                icon.scale = (value / 2) * dpiScale;
                marker.setIcon(icon);
            }
        });
        if (hoverMarker) {
            var hIcon = hoverMarker.getIcon();
            if (hIcon) {
                hIcon.scale = (value / 2) * dpiScale;
                hoverMarker.setIcon(hIcon);
            }
        }
    } else if (key === "map/type") {
        var typeId = indexToMapTypeId(value);
        if (map && map.getMapTypeId() !== typeId) {
            map.setMapTypeId(typeId);
        }
    }
}
</script>
</body>
</html>
