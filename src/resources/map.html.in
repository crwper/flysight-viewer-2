<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>FlySight Map</title>
<style>
html, body, #map {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
}
#error {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: sans-serif;
    font-size: 14px;
    color: #666;
    text-align: center;
    padding: 20px;
}
</style>
<!-- QWebChannel JS (bundled with Qt) -->
<script src="qrc:///qtwebchannel/qwebchannel.js"></script>
</head>
<body>
<div id="map"></div>
<div id="error">
    <p><strong>Google Maps API key not configured.</strong></p>
    <p>Set the GOOGLE_MAPS_API_KEY CMake variable to enable the map.</p>
</div>
<script>
// ===========================================================================
// Task 4.1: API Key Gating
// ===========================================================================
var API_KEY = "@GOOGLE_MAPS_API_KEY@";

if (!API_KEY || API_KEY === "") {
    document.getElementById("error").style.display = "block";
    document.getElementById("map").style.display = "none";
} else {
    // Dynamically load Google Maps API
    var script = document.createElement("script");
    script.src = "https://maps.googleapis.com/maps/api/js?key=" +
                 encodeURIComponent(API_KEY) + "&callback=onMapsApiReady";
    script.async = true;
    script.defer = true;
    document.head.appendChild(script);
}

// ===========================================================================
// Task 4.3: Map Type Index Mapping
// ===========================================================================
var MAP_TYPE_IDS = null; // initialized after Maps API loads

function mapTypeIdToIndex(typeId) {
    if (!MAP_TYPE_IDS) return 0;
    for (var i = 0; i < MAP_TYPE_IDS.length; i++) {
        if (MAP_TYPE_IDS[i] === typeId) return i;
    }
    return 0;
}

function indexToMapTypeId(index) {
    if (!MAP_TYPE_IDS || index < 0 || index >= MAP_TYPE_IDS.length)
        return "roadmap";
    return MAP_TYPE_IDS[index];
}

// ===========================================================================
// Task 4.4: Color Format Conversion (#AARRGGBB -> CSS)
// ===========================================================================
function qtColorToCSS(qtColor) {
    if (!qtColor || qtColor.length < 7) return "rgba(0,0,0,1)";
    // Standard 7-char hex (#RRGGBB) -- pass through
    if (qtColor.length === 7) return qtColor;
    // Qt HexArgb format: #AARRGGBB
    var a = parseInt(qtColor.substring(1, 3), 16) / 255.0;
    var r = parseInt(qtColor.substring(3, 5), 16);
    var g = parseInt(qtColor.substring(5, 7), 16);
    var b = parseInt(qtColor.substring(7, 9), 16);
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
}

function qtColorOpacity(qtColor) {
    if (!qtColor || qtColor.length < 9) return 1.0;
    return parseInt(qtColor.substring(1, 3), 16) / 255.0;
}

function qtColorRGB(qtColor) {
    if (!qtColor || qtColor.length < 9) return qtColor || "#000000";
    return "#" + qtColor.substring(3, 9);
}

// ===========================================================================
// Global state
// ===========================================================================
var map = null;
var bridge = null;

// Track polylines and data (Task 4.5)
var polylines = new Map();
var trackData = new Map();

// Cursor dot markers (Task 4.6)
var cursorMarkers = new Map();

// Preference defaults
var prefLineThickness = 3.0;
var prefTrackOpacity = 0.85;
var prefMarkerSize = 10;

// Hover state (Task 4.7)
var HOVER_THRESHOLD_PX = 10;
var HOVER_MIN_MOVE_PX = 2;
var HOVER_TIME_EPSILON_SEC = 0.02;
var hoverSessionId = "";
var hoverUtcSeconds = NaN;
var lastMouseX = -1;
var lastMouseY = -1;
var pendingHoverRAF = false;
var pendingMouseX = -1;
var pendingMouseY = -1;

// OverlayView for pixel projection (Task 4.7)
var projectionOverlay = null;

// ===========================================================================
// Task 4.3: Map Initialization
// ===========================================================================
function onMapsApiReady() {
    MAP_TYPE_IDS = [
        google.maps.MapTypeId.ROADMAP,    // 0
        google.maps.MapTypeId.SATELLITE,  // 1
        google.maps.MapTypeId.TERRAIN,    // 2
        google.maps.MapTypeId.HYBRID      // 3
    ];

    map = new google.maps.Map(document.getElementById("map"), {
        zoom: 12,
        center: { lat: 0, lng: 0 },
        disableDefaultUI: true,
        zoomControl: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
            style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
            position: google.maps.ControlPosition.TOP_RIGHT
        },
        mapTypeId: google.maps.MapTypeId.ROADMAP
    });

    // Report map type changes back to C++
    map.addListener("maptypeid_changed", function() {
        if (!bridge) return;
        bridge.onMapTypeChanged(mapTypeIdToIndex(map.getMapTypeId()));
    });

    // Set up projection overlay for hover pixel conversion
    initProjectionOverlay();

    // Attach mouse listeners for hover detection
    initHoverListeners();

    // Initialize the QWebChannel bridge
    initBridge();
}

// ===========================================================================
// Task 4.2: QWebChannel Initialization and Bridge Connection
// ===========================================================================
function initBridge() {
    new QWebChannel(qt.webChannelTransport, function(channel) {
        bridge = channel.objects.bridge;

        // Connect C++ -> JS signals
        bridge.tracksChanged.connect(onTracksChanged);
        bridge.cursorDotsChanged.connect(onCursorDotsChanged);
        bridge.fitBounds.connect(onFitBounds);
        bridge.preferenceChanged.connect(onPreferenceChanged);

        // Request all current data now that JS is ready
        bridge.requestInitialData();
    });
}

// ===========================================================================
// Task 4.5: Track Polylines
// ===========================================================================
function onTracksChanged(tracks) {
    // Remove existing polylines
    polylines.forEach(function(pl) { pl.setMap(null); });
    polylines.clear();
    trackData.clear();

    if (!tracks) return;

    for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        trackData.set(track.sessionId, track.points);

        var path = [];
        for (var j = 0; j < track.points.length; j++) {
            path.push({ lat: track.points[j].lat, lng: track.points[j].lon });
        }

        var polyline = new google.maps.Polyline({
            path: path,
            strokeColor: qtColorRGB(track.color),
            strokeOpacity: prefTrackOpacity,
            strokeWeight: prefLineThickness,
            map: map,
            zIndex: 10
        });
        polylines.set(track.sessionId, polyline);
    }
}

// ===========================================================================
// Task 4.6: Cursor Dot Markers
// ===========================================================================
function onCursorDotsChanged(dots) {
    // Remove existing markers
    cursorMarkers.forEach(function(marker) { marker.setMap(null); });
    cursorMarkers.clear();

    if (!dots) return;

    for (var i = 0; i < dots.length; i++) {
        var dot = dots[i];
        var marker = new google.maps.Marker({
            position: { lat: dot.lat, lng: dot.lon },
            map: map,
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                fillColor: qtColorRGB(dot.color),
                fillOpacity: 1.0,
                strokeColor: "#ffffff",
                strokeWeight: 2,
                scale: prefMarkerSize / 2
            },
            zIndex: 20,
            clickable: false
        });
        cursorMarkers.set(dot.sessionId, marker);
    }
}

// ===========================================================================
// Task 4.7: Hover Detection on Polylines
// ===========================================================================

/**
 * Initialize a transparent OverlayView so we can access the
 * MapCanvasProjection for fromLatLngToContainerPixel().
 */
function initProjectionOverlay() {
    var OverlayClass = function() {};
    OverlayClass.prototype = new google.maps.OverlayView();
    OverlayClass.prototype.onAdd = function() {};
    OverlayClass.prototype.onRemove = function() {};
    OverlayClass.prototype.draw = function() {};

    projectionOverlay = new OverlayClass();
    projectionOverlay.setMap(map);
}

/**
 * Convert a LatLng to container pixel coordinates using the overlay projection.
 * Returns {x, y} or null if projection not ready.
 */
function latLngToPixel(lat, lon) {
    if (!projectionOverlay) return null;
    var proj = projectionOverlay.getProjection();
    if (!proj) return null;
    var pt = proj.fromLatLngToContainerPixel(
        new google.maps.LatLng(lat, lon)
    );
    return pt ? { x: pt.x, y: pt.y } : null;
}

/**
 * Squared distance from point P to segment AB, plus parametric u.
 * Ported faithfully from MapDock.qml _distPointToSegment2.
 */
function distPointToSegment2(px, py, ax, ay, bx, by) {
    var abx = bx - ax, aby = by - ay;
    var apx = px - ax, apy = py - ay;
    var denom = abx * abx + aby * aby;
    var u = 0.0;
    if (denom > 1e-9)
        u = (apx * abx + apy * aby) / denom;
    if (u < 0) u = 0;
    else if (u > 1) u = 1;
    var cx = ax + u * abx, cy = ay + u * aby;
    var dx = px - cx, dy = py - cy;
    return { dist2: dx * dx + dy * dy, u: u };
}

/**
 * Perform the hover hit-test at container pixel (mx, my).
 */
function updateHoverAt(mx, my) {
    if (!bridge) return;

    var thr2 = HOVER_THRESHOLD_PX * HOVER_THRESHOLD_PX;
    var bestDist2 = thr2 + 1;
    var bestSessionId = "";
    var bestUtc = NaN;

    // Iterate all tracks and their segments in screen space
    trackData.forEach(function(points, sessionId) {
        if (!points || points.length < 2) return;

        for (var i = 0; i < points.length - 1; i++) {
            var p0 = points[i];
            var p1 = points[i + 1];

            if (p0.t === undefined || p1.t === undefined) continue;

            var A = latLngToPixel(p0.lat, p0.lon);
            var B = latLngToPixel(p1.lat, p1.lon);
            if (!A || !B) continue;

            var r = distPointToSegment2(mx, my, A.x, A.y, B.x, B.y);

            if (r.dist2 < bestDist2) {
                bestDist2 = r.dist2;
                bestSessionId = sessionId;
                bestUtc = p0.t + r.u * (p1.t - p0.t);
            }
        }
    });

    if (bestSessionId !== "" && bestDist2 <= thr2 && !isNaN(bestUtc)) {
        setMapHover(bestSessionId, bestUtc);
    } else {
        clearMapHover();
    }
}

/**
 * Set hover with epsilon filter to avoid spamming C++.
 */
function setMapHover(sessionId, utcSeconds) {
    if (!bridge) return;

    var sessionChanged = (sessionId !== hoverSessionId);
    var timeChanged = sessionChanged
                   || isNaN(hoverUtcSeconds)
                   || Math.abs(utcSeconds - hoverUtcSeconds) > HOVER_TIME_EPSILON_SEC;

    if (!timeChanged) return;

    hoverSessionId = sessionId;
    hoverUtcSeconds = utcSeconds;
    bridge.onMapHover(sessionId, utcSeconds);
}

/**
 * Clear hover state.
 */
function clearMapHover() {
    if (hoverSessionId === "" && isNaN(hoverUtcSeconds)) return;

    hoverSessionId = "";
    hoverUtcSeconds = NaN;

    if (bridge) {
        bridge.onMapHoverClear();
    }
}

/**
 * Attach mouse listeners for hover detection on the map div.
 */
function initHoverListeners() {
    var mapDiv = map.getDiv();

    mapDiv.addEventListener("mousemove", function(e) {
        var rect = mapDiv.getBoundingClientRect();
        pendingMouseX = e.clientX - rect.left;
        pendingMouseY = e.clientY - rect.top;

        if (!pendingHoverRAF) {
            pendingHoverRAF = true;
            requestAnimationFrame(function() {
                pendingHoverRAF = false;

                // Minimum movement filter
                var dx = pendingMouseX - lastMouseX;
                var dy = pendingMouseY - lastMouseY;
                var min2 = HOVER_MIN_MOVE_PX * HOVER_MIN_MOVE_PX;
                if ((dx * dx + dy * dy) < min2) return;

                lastMouseX = pendingMouseX;
                lastMouseY = pendingMouseY;
                updateHoverAt(pendingMouseX, pendingMouseY);
            });
        }
    });

    mapDiv.addEventListener("mouseleave", function() {
        pendingMouseX = -1;
        pendingMouseY = -1;
        lastMouseX = -1;
        lastMouseY = -1;
        clearMapHover();
    });

    // Force hover recalculation when map zoom/center changes
    map.addListener("zoom_changed", function() {
        forceHoverRecalc();
    });
    map.addListener("center_changed", function() {
        forceHoverRecalc();
    });
}

/**
 * Force a hover recalculation at the last known mouse position
 * (e.g. after zoom/pan changes the projection).
 */
function forceHoverRecalc() {
    if (pendingMouseX < 0 || pendingMouseY < 0) return;
    // Reset last processed position to force recalculation
    lastMouseX = -1;
    lastMouseY = -1;
    if (!pendingHoverRAF) {
        pendingHoverRAF = true;
        requestAnimationFrame(function() {
            pendingHoverRAF = false;
            lastMouseX = pendingMouseX;
            lastMouseY = pendingMouseY;
            updateHoverAt(pendingMouseX, pendingMouseY);
        });
    }
}

// ===========================================================================
// Task 4.8: Fit-to-Bounds
// ===========================================================================
function onFitBounds(south, west, north, east) {
    if (!map) return;
    map.fitBounds(
        new google.maps.LatLngBounds(
            { lat: south, lng: west },
            { lat: north, lng: east }
        ),
        40 // padding in pixels
    );
}

// ===========================================================================
// Task 4.9: Preference Reactivity
// ===========================================================================
function onPreferenceChanged(key, value) {
    if (key === "map/lineThickness") {
        prefLineThickness = value;
        polylines.forEach(function(pl) {
            pl.setOptions({ strokeWeight: value });
        });
    } else if (key === "map/trackOpacity") {
        prefTrackOpacity = value;
        polylines.forEach(function(pl) {
            pl.setOptions({ strokeOpacity: value });
        });
    } else if (key === "map/markerSize") {
        prefMarkerSize = value;
        cursorMarkers.forEach(function(marker) {
            var icon = marker.getIcon();
            if (icon) {
                icon.scale = value / 2;
                marker.setIcon(icon);
            }
        });
    } else if (key === "map/type") {
        var typeId = indexToMapTypeId(value);
        if (map && map.getMapTypeId() !== typeId) {
            map.setMapTypeId(typeId);
        }
    }
}
</script>
</body>
</html>
