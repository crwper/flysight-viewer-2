# =============================================================================
# FlySight Viewer - GitHub Actions CI/CD Workflow
# =============================================================================
#
# This workflow builds FlySight Viewer on Windows, macOS (ARM64), and Linux,
# creating platform-specific packages (ZIP, DMG, AppImage) for distribution.
#
# Triggers:
# - Push to any branch
# - Pull requests to any branch
# - Manual workflow dispatch
# - Tags starting with 'v' trigger release creation
#
# =============================================================================

name: Build

on:
  push:
    branches:
      - '**'
    tags:
      - 'v*'
  pull_request:
    branches:
      - '**'
  workflow_dispatch:

# Cancel redundant builds for the same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

env:
  # Qt version to use across all platforms
  QT_VERSION: '6.7.3'
  # Boost version for Windows (match existing local development setup)
  BOOST_VERSION: '1.87.0'
  BOOST_VERSION_UNDERSCORE: '1_87_0'

jobs:
  # ===========================================================================
  # Build Job - Runs on all three platforms
  # ===========================================================================
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-2022
            platform: Windows
            arch: x64
            artifact_ext: zip
          - os: macos-14
            platform: macOS
            arch: arm64
            artifact_ext: dmg
          - os: ubuntu-22.04
            platform: Linux
            arch: x86_64
            artifact_ext: AppImage

    steps:
      # =========================================================================
      # Task 4.2: Checkout and Submodule Initialization
      # =========================================================================
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0  # Full history for version tags

      # =========================================================================
      # Task 4.11: Cache Third-Party Dependencies
      # =========================================================================
      - name: Generate cache key
        id: cache-key
        shell: bash
        run: |
          # Create hash from CMake files and submodule definitions
          # Use openssl which is available on all platforms (Linux, macOS, Windows Git Bash)
          HASH=$(cat cmake/ThirdPartySuperbuild.cmake .gitmodules | openssl dgst -sha256 | awk '{print $NF}')
          echo "hash=${HASH:0:16}" >> $GITHUB_OUTPUT

      - name: Cache third-party dependencies
        id: cache-third-party
        uses: actions/cache@v4
        with:
          path: |
            third-party/GeographicLib-install
            third-party/KDDockWidgets-install
          key: third-party-${{ matrix.os }}-${{ steps.cache-key.outputs.hash }}
          restore-keys: |
            third-party-${{ matrix.os }}-

      # =========================================================================
      # Task 4.3: Platform-Specific Dependency Installation - Windows
      # =========================================================================
      - name: Setup MSVC (Windows)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: Install Ninja (Windows)
        if: runner.os == 'Windows'
        uses: turtlesec-no/get-ninja@main

      # =========================================================================
      # Task 4.5: Configure Boost Installation for Windows
      # =========================================================================
      - name: Install Boost (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $BOOST_ROOT = "C:\hostedtoolcache\windows\Boost\$env:BOOST_VERSION\x64"

          # Download prebuilt Boost binaries for MSVC 14.3 (VS 2022)
          $BOOST_URL = "https://sourceforge.net/projects/boost/files/boost-binaries/$env:BOOST_VERSION/boost_$env:BOOST_VERSION_UNDERSCORE-msvc-14.3-64.exe/download"

          Write-Host "Downloading Boost from: $BOOST_URL"

          # Create WebClient with appropriate settings
          $wc = New-Object System.Net.WebClient
          $wc.Headers.Add("User-Agent", "Other")
          $wc.DownloadFile($BOOST_URL, "$env:TEMP\boost.exe")

          Write-Host "Installing Boost to: $BOOST_ROOT"
          Start-Process -Wait -FilePath "$env:TEMP\boost.exe" -ArgumentList "/SILENT","/SP-","/SUPPRESSMSGBOXES","/DIR=$BOOST_ROOT"

          # Export environment variables for subsequent steps
          # Normalize paths to forward slashes to avoid CMake escape sequence issues
          $BOOST_ROOT_NORMALIZED = $BOOST_ROOT -replace '\\', '/'
          echo "BOOST_ROOT=$BOOST_ROOT_NORMALIZED" >> $env:GITHUB_ENV
          echo "BOOST_LIBRARYDIR=$BOOST_ROOT_NORMALIZED/lib64-msvc-14.3" >> $env:GITHUB_ENV

          Write-Host "Boost installed successfully"
          Get-ChildItem $BOOST_ROOT -Directory | Select-Object -First 5

      # =========================================================================
      # Task 4.3: Platform-Specific Dependency Installation - macOS
      # =========================================================================
      - name: Install dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install ninja boost
          # Export Boost location for CMake
          # On Apple Silicon (arm64), Homebrew installs to /opt/homebrew
          # On Intel Macs, Homebrew installs to /usr/local
          if [ "$(uname -m)" = "arm64" ]; then
            echo "BOOST_ROOT=/opt/homebrew" >> $GITHUB_ENV
          else
            echo "BOOST_ROOT=/usr/local" >> $GITHUB_ENV
          fi

      # =========================================================================
      # Task 4.3: Platform-Specific Dependency Installation - Linux
      # =========================================================================
      - name: Install dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            ninja-build \
            patchelf \
            libboost-all-dev \
            libcups2-dev \
            libxcb-cursor0 \
            libxcb-icccm4 \
            libxcb-image0 \
            libxcb-keysyms1 \
            libxcb-randr0 \
            libxcb-render-util0 \
            libxcb-shape0 \
            libxcb-xinerama0 \
            libxcb-xkb1 \
            libxkbcommon-x11-0 \
            libfuse2 \
            libgl1-mesa-dev \
            libegl1-mesa-dev
          # Export Boost location for CMake
          # On Ubuntu, Boost is installed via apt-get to /usr
          echo "BOOST_ROOT=/usr" >> $GITHUB_ENV

      - name: Verify build tools (Linux)
        if: runner.os == 'Linux'
        run: |
          echo "=== Verifying required build tools ==="

          # patchelf - required for RPATH modification
          if command -v patchelf &> /dev/null; then
            echo "patchelf: $(patchelf --version)"
          else
            echo "ERROR: patchelf not found"
            exit 1
          fi

          # file - used for library identification
          if command -v file &> /dev/null; then
            echo "file: $(file --version | head -1)"
          else
            echo "ERROR: file command not found"
            exit 1
          fi

          echo "=== All required tools available ==="

      # =========================================================================
      # Task 4.4: Configure Qt Installation
      # =========================================================================
      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: ${{ env.QT_VERSION }}
          modules: qtwebengine qtwebchannel qtmultimedia qtpositioning qtserialport qtquick3d qtvirtualkeyboard
          cache: true

      # =========================================================================
      # Task 8.9: Python Version Consistency
      # =========================================================================
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Verify Python configuration
        shell: bash
        run: |
          echo "=== Python Configuration ==="
          python --version
          python -c "import sys; print(f'Prefix: {sys.prefix}')"
          python -c "import sys; print(f'Executable: {sys.executable}')"

          # Verify pybind11 will find this Python
          which python
          python -c "import sysconfig; print(f'Include path: {sysconfig.get_path(\"include\")}')"

          # Export Python root for CMake
          PYTHON_ROOT_DIR=$(python -c "import sys; print(sys.prefix)")
          echo "PYTHON_ROOT_DIR=$PYTHON_ROOT_DIR" >> $GITHUB_ENV
          echo "Python root directory: $PYTHON_ROOT_DIR"

      # =========================================================================
      # Task 7.4: Debug Qt Installation Paths
      # =========================================================================
      - name: Debug Qt installation paths
        shell: bash
        run: |
          echo "=== Qt Environment Variables ==="
          echo "Qt6_DIR: $Qt6_DIR"

          if [ -n "$Qt6_DIR" ]; then
            # Qt6_DIR points to <prefix>/lib/cmake/Qt6/
            QT6_PREFIX=$(cd "$Qt6_DIR/../../.." 2>/dev/null && pwd)
            echo "Derived Qt6 prefix: $QT6_PREFIX"

            # Export for later steps
            echo "QT6_INSTALL_PREFIX=$QT6_PREFIX" >> $GITHUB_ENV

            echo ""
            echo "=== Checking for plugins directory ==="
            for dir in "$QT6_PREFIX/plugins" "$QT6_PREFIX/share/qt6/plugins" "$QT6_PREFIX/lib/qt6/plugins"; do
              if [ -d "$dir" ]; then
                echo "Found plugins at: $dir"
              fi
            done

            echo ""
            echo "=== Checking for QML directory ==="
            for dir in "$QT6_PREFIX/qml" "$QT6_PREFIX/share/qt6/qml" "$QT6_PREFIX/lib/qt6/qml"; do
              if [ -d "$dir" ]; then
                echo "Found QML at: $dir"
              fi
            done
          else
            echo "WARNING: Qt6_DIR is not set"
          fi

      # =========================================================================
      # Task 4.6: Configure CMake Build Steps - Third Party
      # =========================================================================
      - name: Configure third-party superbuild
        if: steps.cache-third-party.outputs.cache-hit != 'true'
        shell: bash
        run: |
          cmake -G Ninja -B build-third-party -S . \
            -DCMAKE_BUILD_TYPE=Release \
            -DFLYSIGHT_BUILD_THIRD_PARTY=ON \
            -DFLYSIGHT_THIRD_PARTY_ONLY=ON

      - name: Build third-party dependencies
        if: steps.cache-third-party.outputs.cache-hit != 'true'
        shell: bash
        run: |
          cmake --build build-third-party --parallel

      # =========================================================================
      # Task 5.4/6.6: Verify Third-Party Installations (GeographicLib, KDDockWidgets)
      # =========================================================================
      - name: Verify third-party installations
        shell: bash
        run: |
          echo "=== Verifying Third-Party Builds ==="

          # ------------------------------------------------------------------
          # Check GeographicLib
          # ------------------------------------------------------------------
          echo ""
          echo "--- GeographicLib Libraries ---"
          GEOGRAPHIC_ROOT="${GITHUB_WORKSPACE}/third-party/GeographicLib-install"
          if [ -d "$GEOGRAPHIC_ROOT/lib" ]; then
            ls -la "$GEOGRAPHIC_ROOT/lib/" || echo "GeographicLib lib directory listing failed"
          else
            echo "WARNING: GeographicLib lib directory not found at $GEOGRAPHIC_ROOT/lib"
          fi

          echo ""
          echo "--- GeographicLib Headers ---"
          if [ -d "$GEOGRAPHIC_ROOT/include/GeographicLib" ]; then
            echo "GeographicLib headers found"
          else
            echo "WARNING: GeographicLib headers MISSING at $GEOGRAPHIC_ROOT/include/GeographicLib"
          fi

          # ------------------------------------------------------------------
          # Check KDDockWidgets
          # ------------------------------------------------------------------
          echo ""
          echo "--- KDDockWidgets ---"
          KDDW_ROOT="${GITHUB_WORKSPACE}/third-party/KDDockWidgets-install"

          if [ -d "$KDDW_ROOT" ]; then
            echo "KDDW_ROOT exists: $KDDW_ROOT"
            ls -la "$KDDW_ROOT/lib/" 2>/dev/null || echo "KDDockWidgets lib directory not found"

            # Check for CMake config
            if [ -f "$KDDW_ROOT/lib/cmake/KDDockWidgets-qt6/KDDockWidgets-qt6Config.cmake" ]; then
              echo "CMake config found in lib/cmake"
            elif [ -f "$KDDW_ROOT/lib64/cmake/KDDockWidgets-qt6/KDDockWidgets-qt6Config.cmake" ]; then
              echo "CMake config found in lib64/cmake"
            else
              echo "WARNING: KDDockWidgets CMake config not found"
              echo "Searching for cmake files..."
              find "$KDDW_ROOT" -name "*.cmake" 2>/dev/null | head -20 || true
            fi
          else
            echo "ERROR: KDDW_ROOT does not exist: $KDDW_ROOT"
            exit 1
          fi

          echo ""
          echo "=== Third-Party Verification Complete ==="

      # =========================================================================
      # Task 4.6: Configure CMake Build Steps - Main Application
      # =========================================================================
      - name: Configure main application
        shell: bash
        run: |
          # Configure the main application build
          # Use src/ directory directly since we have pre-built third-party deps
          cmake -G Ninja -B build -S src \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=build/install \
            -DTHIRD_PARTY_DIR="${GITHUB_WORKSPACE}/third-party" \
            -DGEOGRAPHIC_ROOT="${GITHUB_WORKSPACE}/third-party/GeographicLib-install" \
            -DKDDW_ROOT="${GITHUB_WORKSPACE}/third-party/KDDockWidgets-install" \
            ${PYTHON_ROOT_DIR:+-DPython_ROOT_DIR="$PYTHON_ROOT_DIR"} \
            ${QT6_INSTALL_PREFIX:+-DQT6_INSTALL_PREFIX="$QT6_INSTALL_PREFIX"} \
            ${BOOST_ROOT:+-DBOOST_ROOT="$BOOST_ROOT"} \
            ${BOOST_LIBRARYDIR:+-DBOOST_LIBRARYDIR="$BOOST_LIBRARYDIR"} \
            ${GOOGLE_MAPS_API_KEY:+-DGOOGLE_MAPS_API_KEY="$GOOGLE_MAPS_API_KEY"}

      # =========================================================================
      # Task 3.5: Verify Boost Discovery
      # =========================================================================
      - name: Verify Boost discovery
        shell: bash
        run: |
          echo "=== Boost Discovery Verification ==="

          # Check CMakeCache.txt for Boost variables
          if [ -f "build/CMakeCache.txt" ]; then
            echo "BOOST_ROOT:"
            grep "^BOOST_ROOT:" build/CMakeCache.txt || echo "  (not set)"

            echo "BOOST_LIBRARYDIR:"
            grep "^BOOST_LIBRARYDIR:" build/CMakeCache.txt || echo "  (not set)"

            echo "Boost_FOUND:"
            grep "Boost_FOUND" build/CMakeCache.txt || echo "  (not in cache)"

            echo "Boost_VERSION:"
            grep "Boost_VERSION:" build/CMakeCache.txt || echo "  (not set)"

            echo "Boost_INCLUDE_DIRS:"
            grep "Boost_INCLUDE_DIR" build/CMakeCache.txt | head -3 || echo "  (not set)"

            echo "Boost component libraries found:"
            grep "Boost_.*_LIBRARY" build/CMakeCache.txt | head -10 || echo "  (none found)"
          else
            echo "ERROR: build/CMakeCache.txt not found"
            exit 1
          fi

          echo "=== Boost verification complete ==="

      - name: Build main application
        shell: bash
        run: |
          cmake --build build --parallel --config Release

      # =========================================================================
      # Task 4.7: Implement Installation and Deployment Steps
      # =========================================================================
      - name: Install application
        shell: bash
        run: |
          cmake --install build --config Release

      - name: Verify deployment output (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: |
          echo "=== Verifying Windows deployment ==="
          ls -la build/install/ || true
          ls -la build/install/python/ || true
          echo "Checking for executable..."
          test -f build/install/FlySightViewer.exe && echo "FlySightViewer.exe found" || echo "WARNING: FlySightViewer.exe not found"

          echo ""
          echo "=== Checking qt.conf ==="
          if [ -f "build/install/qt.conf" ]; then
            echo "qt.conf found:"
            cat build/install/qt.conf
          else
            echo "WARNING: qt.conf not found"
          fi

          echo ""
          echo "=== Checking critical DLLs ==="
          MISSING=0
          for dll in vcruntime140.dll msvcp140.dll; do
            if [ -f "build/install/$dll" ]; then
              echo "OK: $dll"
            else
              echo "ERROR: $dll MISSING"
              MISSING=1
            fi
          done
          # KDDockWidgets DLL name includes version suffix (e.g. kddockwidgets-qt62.dll)
          if ls build/install/kddockwidgets-qt6*.dll 1>/dev/null 2>&1; then
            echo "OK: KDDockWidgets DLL found"
          else
            echo "ERROR: KDDockWidgets DLL MISSING"
            MISSING=1
          fi
          # GeographicLib DLL name varies by version
          if ls build/install/Geographic*.dll 1>/dev/null 2>&1; then
            echo "OK: GeographicLib DLL found"
          else
            echo "ERROR: GeographicLib DLL MISSING"
            MISSING=1
          fi
          # vc_redist.x64.exe should NOT be present (we use app-local DLLs instead)
          if ls build/install/vc_redist*.exe 1>/dev/null 2>&1; then
            echo "WARNING: vc_redist installer found (should not be bundled)"
          fi
          if [ $MISSING -ne 0 ]; then
            echo ""
            echo "FATAL: Missing critical files in install directory"
            ls -la build/install/
            exit 1
          fi

      # =========================================================================
      # Phase 9: Comprehensive macOS RPATH Verification
      # =========================================================================
      - name: Verify deployment output (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "=== Verifying macOS deployment ==="
          BUNDLE="build/install/FlySight Viewer.app"

          echo ""
          echo "--- Bundle Structure ---"
          ls -la "$BUNDLE/Contents/" || true
          ls -la "$BUNDLE/Contents/MacOS/" || true
          ls -la "$BUNDLE/Contents/Frameworks/" | head -20 || true

          echo ""
          echo "--- Executable RPATH Verification ---"
          EXE="$BUNDLE/Contents/MacOS/FlySightViewer"
          if [ -f "$EXE" ]; then
            echo "Executable rpaths:"
            otool -l "$EXE" | grep -A2 "LC_RPATH" || echo "No LC_RPATH found"

            echo ""
            echo "Executable dependencies:"
            otool -L "$EXE" | head -20

            echo ""
            echo "Checking for absolute paths (potential issues):"
            otool -L "$EXE" | grep -v "@" | grep -v "/usr/lib" | grep -v "/System" | grep "dylib" || echo "No problematic paths found"
          else
            echo "WARNING: Executable not found"
          fi

          echo ""
          echo "--- Frameworks Library IDs ---"
          FRAMEWORKS_DIR="$BUNDLE/Contents/Frameworks"
          for dylib in "$FRAMEWORKS_DIR"/*.dylib; do
            [ -L "$dylib" ] && continue  # Skip symlinks
            [ -f "$dylib" ] || continue
            name=$(basename "$dylib")
            id=$(otool -D "$dylib" 2>/dev/null | tail -1)
            if [[ "$id" == "@rpath/"* ]]; then
              echo "OK: $name -> $id"
            else
              echo "WARN: $name -> $id (should be @rpath/...)"
            fi
          done

          echo ""
          echo "--- Checking Third-Party Libraries ---"
          for lib in libGeographic; do
            found=$(find "$FRAMEWORKS_DIR" -name "${lib}*.dylib" ! -type l 2>/dev/null | head -1)
            if [ -n "$found" ]; then
              echo "Found: $(basename "$found")"
              # Check for problematic dependencies
              bad_deps=$(otool -L "$found" | grep -v "@" | grep -v "/usr/lib" | grep -v "/System" | grep "dylib" || true)
              if [ -n "$bad_deps" ]; then
                echo "  WARNING: Has absolute paths:"
                echo "$bad_deps" | sed 's/^/    /'
              fi
            else
              echo "MISSING: ${lib}*.dylib"
            fi
          done

          echo ""
          echo "--- Checking libpython ---"
          libpython=$(find "$FRAMEWORKS_DIR" -name "libpython*.dylib" ! -type l 2>/dev/null | head -1)
          if [ -n "$libpython" ]; then
            echo "Found: $(basename "$libpython")"
            echo "ID: $(otool -D "$libpython" | tail -1)"
          else
            echo "MISSING: libpython*.dylib"
          fi

          echo ""
          echo "--- Checking pybind11 Module ---"
          bridge=$(find "$BUNDLE" -name "flysight_cpp_bridge*.so" 2>/dev/null | head -1)
          if [ -n "$bridge" ]; then
            echo "Found: $bridge"
            echo "Dependencies:"
            otool -L "$bridge" | head -10
            echo "RPaths:"
            otool -l "$bridge" | grep -A2 "LC_RPATH" || echo "No LC_RPATH"
          else
            echo "MISSING: flysight_cpp_bridge module"
          fi

          echo ""
          echo "--- Checking qt.conf ---"
          if [ -f "$BUNDLE/Contents/Resources/qt.conf" ]; then
            echo "qt.conf found:"
            cat "$BUNDLE/Contents/Resources/qt.conf"
          else
            echo "WARNING: qt.conf not found"
          fi

          echo ""
          echo "=== macOS Verification Complete ==="

      - name: Verify deployment output (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "=== Verifying Linux deployment ==="
          APPDIR="build/install/FlySightViewer.AppDir"

          # Check AppDir structure
          echo "--- AppDir Structure ---"
          for dir in usr/bin usr/lib usr/plugins usr/qml usr/share/python; do
            if [ -d "$APPDIR/$dir" ]; then
              echo "  $dir: OK ($(ls -1 "$APPDIR/$dir" 2>/dev/null | wc -l) items)"
            else
              echo "  $dir: MISSING"
            fi
          done

          echo ""
          echo "--- AppRun and Desktop Files ---"
          test -x "$APPDIR/AppRun" && echo "  AppRun: OK (executable)" || echo "  AppRun: MISSING or not executable"
          test -f "$APPDIR/FlySightViewer.desktop" && echo "  Desktop file: OK" || echo "  Desktop file: MISSING"
          test -f "$APPDIR/FlySightViewer.png" && echo "  Icon: OK" || echo "  Icon: MISSING"

          echo ""
          echo "--- Third-Party Libraries ---"
          for lib in libGeographic libkddockwidgets; do
            found=$(find "$APPDIR/usr/lib" -name "${lib}*.so*" 2>/dev/null | head -1)
            if [ -n "$found" ]; then
              echo "  $lib: $(basename $found)"
            else
              echo "  $lib: NOT FOUND"
            fi
          done

          echo ""
          echo "--- Qt Components ---"
          if [ -d "$APPDIR/usr/plugins/platforms" ]; then
            echo "  Platform plugins: $(ls "$APPDIR/usr/plugins/platforms/" 2>/dev/null)"
          else
            echo "  Platform plugins: MISSING"
          fi
          test -f "$APPDIR/usr/bin/qt.conf" && echo "  qt.conf: OK" || echo "  qt.conf: MISSING"

          echo ""
          echo "--- Python Bundle ---"
          PYTHON_DIR="$APPDIR/usr/share/python"
          if [ -d "$PYTHON_DIR" ]; then
            echo "  Python directory: OK"
            PYTHON_BIN="$PYTHON_DIR/bin/python3"
            if [ -x "$PYTHON_BIN" ]; then
              echo "  Python version: $("$PYTHON_BIN" --version 2>&1)"
            else
              echo "  Python executable: MISSING"
            fi

            # Check for bridge module
            BRIDGE=$(find "$PYTHON_DIR" -name "flysight_cpp_bridge*.so" 2>/dev/null | head -1)
            if [ -n "$BRIDGE" ]; then
              echo "  Bridge module: $(basename $BRIDGE)"
              # Verify RPATH
              RPATH=$(patchelf --print-rpath "$BRIDGE" 2>/dev/null)
              echo "  Bridge RPATH: $RPATH"
            else
              echo "  Bridge module: NOT FOUND"
            fi
          else
            echo "  Python bundle: MISSING"
          fi

          echo ""
          echo "--- Executable RPATH ---"
          EXE="$APPDIR/usr/bin/flysight-viewer"
          if [ -f "$EXE" ]; then
            RPATH=$(patchelf --print-rpath "$EXE" 2>/dev/null)
            echo "  flysight-viewer RPATH: $RPATH"
          fi

          echo ""
          echo "=== Verification Complete ==="

      # =========================================================================
      # Task 4.7: Linux AppImage Creation
      # =========================================================================
      - name: Create AppImage (Linux)
        if: runner.os == 'Linux'
        env:
          APPIMAGE_EXTRACT_AND_RUN: 1
        run: |
          echo "=== Creating AppImage ==="

          # Run the appimage target if available, otherwise create manually
          if cmake --build build --target appimage 2>/dev/null; then
            echo "AppImage created via CMake target"
          else
            echo "Creating AppImage manually..."

            # Download appimagetool
            APPIMAGETOOL_URL="https://github.com/AppImage/appimagetool/releases/download/continuous/appimagetool-x86_64.AppImage"
            wget -q -O appimagetool "$APPIMAGETOOL_URL"
            chmod +x appimagetool

            # Create AppImage
            APPDIR="build/install/FlySightViewer.AppDir"
            if [ -d "$APPDIR" ]; then
              ./appimagetool "$APPDIR" "FlySightViewer-${{ matrix.arch }}.AppImage"
              mv "FlySightViewer-${{ matrix.arch }}.AppImage" build/
            else
              echo "ERROR: AppDir not found at $APPDIR"
              exit 1
            fi
          fi

          echo "AppImage creation complete"
          ls -la build/*.AppImage || true

      - name: Verify AppImage (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "=== Verifying AppImage ==="

          APPIMAGE=$(find build -name "*.AppImage" -type f 2>/dev/null | head -1)
          if [ -z "$APPIMAGE" ]; then
            echo "WARNING: No AppImage found in build/"
            ls -la build/
            exit 0
          fi

          echo "AppImage: $APPIMAGE"
          echo "Size: $(ls -lh "$APPIMAGE" | awk '{print $5}')"

          # Test extraction (doesn't require FUSE)
          echo ""
          echo "--- Testing AppImage extraction ---"
          export APPIMAGE_EXTRACT_AND_RUN=1

          # Extract to temporary directory
          EXTRACT_DIR=$(mktemp -d)
          cd "$EXTRACT_DIR"
          "$GITHUB_WORKSPACE/$APPIMAGE" --appimage-extract >/dev/null 2>&1

          if [ -d "squashfs-root" ]; then
            echo "Extraction: OK"
            echo "Contents:"
            ls -la squashfs-root/

            # Quick sanity check
            echo ""
            echo "--- Sanity checks ---"
            test -x squashfs-root/AppRun && echo "AppRun: OK" || echo "AppRun: FAILED"
            test -x squashfs-root/usr/bin/flysight-viewer && echo "Executable: OK" || echo "Executable: FAILED"
            test -f squashfs-root/usr/bin/qt.conf && echo "qt.conf: OK" || echo "qt.conf: MISSING"

            # Check RPATH in extracted files
            echo ""
            echo "--- RPATH verification ---"
            if [ -f squashfs-root/usr/bin/flysight-viewer ]; then
              RPATH=$(patchelf --print-rpath squashfs-root/usr/bin/flysight-viewer 2>/dev/null)
              echo "flysight-viewer RPATH: $RPATH"
            fi

            BRIDGE=$(find squashfs-root/usr/share/python -name "flysight_cpp_bridge*.so" 2>/dev/null | head -1)
            if [ -n "$BRIDGE" ]; then
              BRIDGE_RPATH=$(patchelf --print-rpath "$BRIDGE" 2>/dev/null)
              echo "Bridge module RPATH: $BRIDGE_RPATH"
            fi
          else
            echo "Extraction: FAILED"
          fi

          # Cleanup
          cd "$GITHUB_WORKSPACE"
          rm -rf "$EXTRACT_DIR"

          echo ""
          echo "=== AppImage Verification Complete ==="

      # =========================================================================
      # Task 4.8: Implement Artifact Packaging
      # =========================================================================
      - name: Package with CPack (Windows)
        if: runner.os == 'Windows'
        shell: bash
        working-directory: build
        run: |
          cpack -G ZIP -C Release
          echo "=== CPack output ==="
          ls -la *.zip || true

      - name: Package with CPack (macOS)
        if: runner.os == 'macOS'
        working-directory: build
        run: |
          cpack -G DragNDrop -C Release
          echo "=== CPack output ==="
          ls -la *.dmg || true

      # =========================================================================
      # Task 4.8: Collect Artifacts
      # =========================================================================
      - name: Collect artifacts
        shell: bash
        run: |
          mkdir -p artifacts

          if [ "${{ runner.os }}" == "Windows" ]; then
            # CI artifact: copy install directory so users get a single folder
            # (upload-artifact wraps in one zip -> unzip -> FlySightViewer/ -> files)
            cp -r build/install artifacts/FlySightViewer
          elif [ "${{ runner.os }}" == "macOS" ]; then
            cp build/*.dmg artifacts/ 2>/dev/null || true
            # Fallback: create dmg manually if CPack didn't work
            if [ ! -f artifacts/*.dmg ]; then
              hdiutil create -volname "FlySight Viewer" -srcfolder "build/install/FlySight Viewer.app" -ov -format UDZO artifacts/FlySightViewer-${{ matrix.platform }}-${{ matrix.arch }}.dmg 2>/dev/null || true
            fi
          elif [ "${{ runner.os }}" == "Linux" ]; then
            cp build/*.AppImage artifacts/ 2>/dev/null || true
          fi

          echo "=== Collected artifacts ==="
          ls -la artifacts/

      # =========================================================================
      # Task 4.9: Implement Artifact Upload
      # =========================================================================
      - name: Upload artifacts
        if: runner.os != 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: FlySightViewer-${{ matrix.platform }}-${{ matrix.arch }}
          path: artifacts/*
          retention-days: 30
          if-no-files-found: warn

      - name: Upload artifacts (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: FlySightViewer-${{ matrix.platform }}-${{ matrix.arch }}
          path: artifacts/FlySightViewer/
          retention-days: 30
          if-no-files-found: warn

      - name: Upload release package (Windows)
        if: runner.os == 'Windows' && startsWith(github.ref, 'refs/tags/v')
        uses: actions/upload-artifact@v4
        with:
          name: FlySightViewer-${{ matrix.platform }}-${{ matrix.arch }}-release
          path: build/*.zip
          retention-days: 30
          if-no-files-found: warn

  # ===========================================================================
  # Task 4.10: Release Publishing Job
  # ===========================================================================
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Download release artifacts (Windows)
        uses: actions/download-artifact@v4
        with:
          pattern: "*-release"
          path: release-artifacts
          merge-multiple: true

      - name: Download release artifacts (non-Windows)
        uses: actions/download-artifact@v4
        with:
          pattern: "FlySightViewer-{macOS,Linux}-*"
          path: release-artifacts
          merge-multiple: true

      - name: List downloaded artifacts
        run: |
          echo "=== Downloaded artifacts ==="
          find release-artifacts -type f -ls

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          draft: true
          generate_release_notes: true
          files: |
            release-artifacts/*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
