# =============================================================================
# FlySight Viewer - GitHub Actions CI/CD Workflow
# =============================================================================
#
# This workflow builds FlySight Viewer on Windows, macOS (ARM64), and Linux,
# creating platform-specific packages (ZIP, DMG, AppImage) for distribution.
#
# Triggers:
# - Push to any branch
# - Pull requests to any branch
# - Manual workflow dispatch
# - Tags starting with 'v' trigger release creation
#
# =============================================================================

name: Build

on:
  push:
    branches:
      - '**'
    tags:
      - 'v*'
  pull_request:
    branches:
      - '**'
  workflow_dispatch:

# Cancel redundant builds for the same branch/PR.
# Uses SHA for push events so that a simultaneous branch + tag push
# (e.g., `git push origin master v2026.02.0`) lands in one group and
# the tag build cancels the redundant branch build.
concurrency:
  group: >-
    ${{ github.workflow }}-${{
      github.event_name == 'pull_request'
        && github.head_ref
        || github.sha
    }}
  cancel-in-progress: true

env:
  # Qt version to use across all platforms
  QT_VERSION: '6.9.3'
  # Boost version for Windows (match existing local development setup)
  BOOST_VERSION: '1.87.0'
  BOOST_VERSION_UNDERSCORE: '1_87_0'

jobs:
  # ===========================================================================
  # Build Job - Runs on all three platforms
  # ===========================================================================
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-2022
            platform: Windows
            arch: x64
            artifact_ext: zip
          - os: macos-14
            platform: macOS
            arch: arm64
            artifact_ext: dmg
          - os: ubuntu-22.04
            platform: Linux
            arch: x86_64
            artifact_ext: AppImage

    steps:
      # =========================================================================
      # Task 4.2: Checkout and Submodule Initialization
      # =========================================================================
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0  # Full history for version tags

      # =========================================================================
      # Task 4.11: Cache Third-Party Dependencies
      # =========================================================================
      - name: Generate cache key
        id: cache-key
        shell: bash
        run: |
          # Create hash from CMake files and submodule definitions
          # Use openssl which is available on all platforms (Linux, macOS, Windows Git Bash)
          HASH=$(cat cmake/ThirdPartySuperbuild.cmake .gitmodules | openssl dgst -sha256 | awk '{print $NF}')
          echo "hash=${HASH:0:16}" >> $GITHUB_OUTPUT

      - name: Cache third-party dependencies
        id: cache-third-party
        uses: actions/cache@v4
        with:
          path: |
            third-party/GeographicLib-install
            third-party/KDDockWidgets-install
          key: third-party-${{ matrix.os }}-${{ steps.cache-key.outputs.hash }}
          restore-keys: |
            third-party-${{ matrix.os }}-

      # =========================================================================
      # Task 4.3: Platform-Specific Dependency Installation - Windows
      # =========================================================================
      - name: Setup MSVC (Windows)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: Install Ninja (Windows)
        if: runner.os == 'Windows'
        uses: turtlesec-no/get-ninja@main

      # =========================================================================
      # Task 4.5: Configure Boost Installation for Windows
      # =========================================================================
      - name: Install Boost (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $BOOST_ROOT = "C:\hostedtoolcache\windows\Boost\$env:BOOST_VERSION\x64"

          # Download prebuilt Boost binaries for MSVC 14.3 (VS 2022)
          $BOOST_URL = "https://sourceforge.net/projects/boost/files/boost-binaries/$env:BOOST_VERSION/boost_$env:BOOST_VERSION_UNDERSCORE-msvc-14.3-64.exe/download"

          Write-Host "Downloading Boost from: $BOOST_URL"

          # Create WebClient with appropriate settings
          $wc = New-Object System.Net.WebClient
          $wc.Headers.Add("User-Agent", "Other")
          $wc.DownloadFile($BOOST_URL, "$env:TEMP\boost.exe")

          Write-Host "Installing Boost to: $BOOST_ROOT"
          Start-Process -Wait -FilePath "$env:TEMP\boost.exe" -ArgumentList "/SILENT","/SP-","/SUPPRESSMSGBOXES","/DIR=$BOOST_ROOT"

          # Export environment variables for subsequent steps
          # Normalize paths to forward slashes to avoid CMake escape sequence issues
          $BOOST_ROOT_NORMALIZED = $BOOST_ROOT -replace '\\', '/'
          echo "BOOST_ROOT=$BOOST_ROOT_NORMALIZED" >> $env:GITHUB_ENV
          echo "BOOST_LIBRARYDIR=$BOOST_ROOT_NORMALIZED/lib64-msvc-14.3" >> $env:GITHUB_ENV

          Write-Host "Boost installed successfully"
          Get-ChildItem $BOOST_ROOT -Directory | Select-Object -First 5

      # =========================================================================
      # Task 4.3: Platform-Specific Dependency Installation - macOS
      # =========================================================================
      - name: Install dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install ninja boost
          # Export Boost location for CMake
          # On Apple Silicon (arm64), Homebrew installs to /opt/homebrew
          # On Intel Macs, Homebrew installs to /usr/local
          if [ "$(uname -m)" = "arm64" ]; then
            echo "BOOST_ROOT=/opt/homebrew" >> $GITHUB_ENV
          else
            echo "BOOST_ROOT=/usr/local" >> $GITHUB_ENV
          fi

      # =========================================================================
      # macOS Code Signing: Import Certificate
      # =========================================================================
      - name: Import code signing certificate (macOS)
        if: runner.os == 'macOS'
        env:
          MACOS_CERTIFICATE_P12_BASE64: ${{ secrets.MACOS_CERTIFICATE_P12_BASE64 }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          if [ -z "$MACOS_CERTIFICATE_P12_BASE64" ]; then
            echo "No signing certificate available, skipping"
            exit 0
          fi

          # Create a temporary keychain
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Decode and import certificate
          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$MACOS_CERTIFICATE_P12_BASE64" | base64 --decode > "$CERT_PATH"

          security import "$CERT_PATH" \
            -P "$MACOS_CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Remove the decoded certificate file
          rm -f "$CERT_PATH"

          # Set key partition list to allow codesign access without UI prompt
          security set-key-partition-list -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Add the temporary keychain to the search list (prepend so it's found first)
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

          # Export keychain path for cleanup step
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV

          # Verify the identity is available
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          echo "Certificate imported successfully"

      - name: Set code signing environment (macOS)
        if: runner.os == 'macOS'
        env:
          MACOS_CODESIGN_IDENTITY: ${{ secrets.MACOS_CODESIGN_IDENTITY }}
        run: |
          if [ -n "$MACOS_CODESIGN_IDENTITY" ]; then
            echo "FLYSIGHT_CODESIGN_IDENTITY=$MACOS_CODESIGN_IDENTITY" >> $GITHUB_ENV
            echo "Code signing: distribution"
          else
            echo "FLYSIGHT_CODESIGN_IDENTITY=-" >> $GITHUB_ENV
            echo "Code signing: ad-hoc (secrets not available)"
          fi

      # =========================================================================
      # Task 4.3: Platform-Specific Dependency Installation - Linux
      # =========================================================================
      - name: Install dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            ninja-build \
            patchelf \
            libboost-all-dev \
            libcups2-dev \
            libxcb-cursor0 \
            libxcb-icccm4 \
            libxcb-image0 \
            libxcb-keysyms1 \
            libxcb-randr0 \
            libxcb-render-util0 \
            libxcb-shape0 \
            libxcb-xinerama0 \
            libxcb-xkb1 \
            libxkbcommon-x11-0 \
            libfuse2 \
            libgl1-mesa-dev \
            libegl1-mesa-dev
          # Export Boost location for CMake
          # On Ubuntu, Boost is installed via apt-get to /usr
          echo "BOOST_ROOT=/usr" >> $GITHUB_ENV

      - name: Verify build tools (Linux)
        if: runner.os == 'Linux'
        run: |
          echo "=== Verifying required build tools ==="

          # patchelf - required for RPATH modification
          if command -v patchelf &> /dev/null; then
            echo "patchelf: $(patchelf --version)"
          else
            echo "ERROR: patchelf not found"
            exit 1
          fi

          # file - used for library identification
          if command -v file &> /dev/null; then
            echo "file: $(file --version | head -1)"
          else
            echo "ERROR: file command not found"
            exit 1
          fi

          echo "=== All required tools available ==="

      # =========================================================================
      # Task 4.4: Configure Qt Installation
      # =========================================================================
      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: ${{ env.QT_VERSION }}
          modules: qtwebengine qtwebchannel qtmultimedia qtpositioning qtserialport qtquick3d qtvirtualkeyboard
          cache: true

      # =========================================================================
      # Task 8.9: Python Version Consistency
      # =========================================================================
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Verify Python configuration
        shell: bash
        run: |
          echo "=== Python Configuration ==="
          python --version
          python -c "import sys; print(f'Prefix: {sys.prefix}')"
          python -c "import sys; print(f'Executable: {sys.executable}')"

          # Verify pybind11 will find this Python
          which python
          python -c "import sysconfig; print(f'Include path: {sysconfig.get_path(\"include\")}')"

          # Export Python root for CMake
          PYTHON_ROOT_DIR=$(python -c "import sys; print(sys.prefix)")
          echo "PYTHON_ROOT_DIR=$PYTHON_ROOT_DIR" >> $GITHUB_ENV
          echo "Python root directory: $PYTHON_ROOT_DIR"

      # =========================================================================
      # Task 7.4: Debug Qt Installation Paths
      # =========================================================================
      - name: Debug Qt installation paths
        shell: bash
        run: |
          echo "=== Qt Environment Variables ==="
          echo "Qt6_DIR: $Qt6_DIR"

          if [ -n "$Qt6_DIR" ]; then
            # Qt6_DIR points to <prefix>/lib/cmake/Qt6/
            QT6_PREFIX=$(cd "$Qt6_DIR/../../.." 2>/dev/null && pwd)
            echo "Derived Qt6 prefix: $QT6_PREFIX"

            # Export for later steps
            echo "QT6_INSTALL_PREFIX=$QT6_PREFIX" >> $GITHUB_ENV

            echo ""
            echo "=== Checking for plugins directory ==="
            for dir in "$QT6_PREFIX/plugins" "$QT6_PREFIX/share/qt6/plugins" "$QT6_PREFIX/lib/qt6/plugins"; do
              if [ -d "$dir" ]; then
                echo "Found plugins at: $dir"
              fi
            done

            echo ""
            echo "=== Checking for QML directory ==="
            for dir in "$QT6_PREFIX/qml" "$QT6_PREFIX/share/qt6/qml" "$QT6_PREFIX/lib/qt6/qml"; do
              if [ -d "$dir" ]; then
                echo "Found QML at: $dir"
              fi
            done
          else
            echo "WARNING: Qt6_DIR is not set"
          fi

      # =========================================================================
      # Task 4.6: Configure CMake Build Steps - Third Party
      # =========================================================================
      - name: Configure third-party superbuild
        if: steps.cache-third-party.outputs.cache-hit != 'true'
        shell: bash
        run: |
          cmake -G Ninja -B build-third-party -S . \
            -DCMAKE_BUILD_TYPE=Release \
            -DFLYSIGHT_BUILD_THIRD_PARTY=ON \
            -DFLYSIGHT_THIRD_PARTY_ONLY=ON

      - name: Build third-party dependencies
        if: steps.cache-third-party.outputs.cache-hit != 'true'
        shell: bash
        run: |
          cmake --build build-third-party --parallel

      # =========================================================================
      # Task 5.4/6.6: Verify Third-Party Installations (GeographicLib, KDDockWidgets)
      # =========================================================================
      - name: Verify third-party installations
        shell: bash
        run: |
          echo "=== Verifying Third-Party Builds ==="

          # ------------------------------------------------------------------
          # Check GeographicLib
          # ------------------------------------------------------------------
          echo ""
          echo "--- GeographicLib Libraries ---"
          GEOGRAPHIC_ROOT="${GITHUB_WORKSPACE}/third-party/GeographicLib-install"
          if [ -d "$GEOGRAPHIC_ROOT/lib" ]; then
            ls -la "$GEOGRAPHIC_ROOT/lib/" || echo "GeographicLib lib directory listing failed"
          else
            echo "WARNING: GeographicLib lib directory not found at $GEOGRAPHIC_ROOT/lib"
          fi

          echo ""
          echo "--- GeographicLib Headers ---"
          if [ -d "$GEOGRAPHIC_ROOT/include/GeographicLib" ]; then
            echo "GeographicLib headers found"
          else
            echo "WARNING: GeographicLib headers MISSING at $GEOGRAPHIC_ROOT/include/GeographicLib"
          fi

          # ------------------------------------------------------------------
          # Check KDDockWidgets
          # ------------------------------------------------------------------
          echo ""
          echo "--- KDDockWidgets ---"
          KDDW_ROOT="${GITHUB_WORKSPACE}/third-party/KDDockWidgets-install"

          if [ -d "$KDDW_ROOT" ]; then
            echo "KDDW_ROOT exists: $KDDW_ROOT"
            ls -la "$KDDW_ROOT/lib/" 2>/dev/null || echo "KDDockWidgets lib directory not found"

            # Check for CMake config
            if [ -f "$KDDW_ROOT/lib/cmake/KDDockWidgets-qt6/KDDockWidgets-qt6Config.cmake" ]; then
              echo "CMake config found in lib/cmake"
            elif [ -f "$KDDW_ROOT/lib64/cmake/KDDockWidgets-qt6/KDDockWidgets-qt6Config.cmake" ]; then
              echo "CMake config found in lib64/cmake"
            else
              echo "WARNING: KDDockWidgets CMake config not found"
              echo "Searching for cmake files..."
              find "$KDDW_ROOT" -name "*.cmake" 2>/dev/null | head -20 || true
            fi
          else
            echo "ERROR: KDDW_ROOT does not exist: $KDDW_ROOT"
            exit 1
          fi

          echo ""
          echo "=== Third-Party Verification Complete ==="

      # =========================================================================
      # Task 4.6: Configure CMake Build Steps - Main Application
      # =========================================================================
      - name: Extract version from tag
        id: version
        shell: bash
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION="${{ github.ref }}"
            VERSION="${VERSION#refs/tags/v}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "Detected version from tag: $VERSION"
            # Tagged build: display version matches clean version
            echo "FLYSIGHT_VERSION_DISPLAY=$VERSION" >> $GITHUB_ENV
          else
            echo "version=" >> $GITHUB_OUTPUT
            echo "No version tag detected (will use git describe fallback)"
            # Non-tagged build: compute display version from git describe
            DISPLAY=$(git describe --tags --match "v[0-9]*" 2>/dev/null | sed 's/^v//' || true)
            if [ -z "$DISPLAY" ]; then
              SHORT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
              DISPLAY="0.0.0-g${SHORT_HASH}"
            fi
            echo "FLYSIGHT_VERSION_DISPLAY=$DISPLAY" >> $GITHUB_ENV
          fi
          echo "Display version: $FLYSIGHT_VERSION_DISPLAY"

      - name: Configure main application
        shell: bash
        env:
          GOOGLE_MAPS_API_KEY: ${{ secrets.GOOGLE_MAPS_API_KEY }}
          FLYSIGHT_VERSION: ${{ steps.version.outputs.version }}
        run: |
          # Configure the main application build
          # Use src/ directory directly since we have pre-built third-party deps
          cmake -G Ninja -B build -S src \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=build/install \
            -DTHIRD_PARTY_DIR="${GITHUB_WORKSPACE}/third-party" \
            -DGEOGRAPHIC_ROOT="${GITHUB_WORKSPACE}/third-party/GeographicLib-install" \
            -DKDDW_ROOT="${GITHUB_WORKSPACE}/third-party/KDDockWidgets-install" \
            ${PYTHON_ROOT_DIR:+-DPython_ROOT_DIR="$PYTHON_ROOT_DIR"} \
            ${QT6_INSTALL_PREFIX:+-DQT6_INSTALL_PREFIX="$QT6_INSTALL_PREFIX"} \
            ${BOOST_ROOT:+-DBOOST_ROOT="$BOOST_ROOT"} \
            ${BOOST_LIBRARYDIR:+-DBOOST_LIBRARYDIR="$BOOST_LIBRARYDIR"} \
            ${GOOGLE_MAPS_API_KEY:+-DGOOGLE_MAPS_API_KEY="$GOOGLE_MAPS_API_KEY"} \
            ${FLYSIGHT_VERSION:+-DFLYSIGHT_VERSION_OVERRIDE="$FLYSIGHT_VERSION"} \
            -DFLYSIGHT_CODESIGN_IDENTITY="${FLYSIGHT_CODESIGN_IDENTITY:--}" \
            -DFLYSIGHT_CODESIGN_ENTITLEMENTS="${GITHUB_WORKSPACE}/src/FlySightViewer.entitlements"

      # =========================================================================
      # Task 3.5: Verify Boost Discovery
      # =========================================================================
      - name: Verify Boost discovery
        shell: bash
        run: |
          echo "=== Boost Discovery Verification ==="

          # Check CMakeCache.txt for Boost variables
          if [ -f "build/CMakeCache.txt" ]; then
            echo "BOOST_ROOT:"
            grep "^BOOST_ROOT:" build/CMakeCache.txt || echo "  (not set)"

            echo "BOOST_LIBRARYDIR:"
            grep "^BOOST_LIBRARYDIR:" build/CMakeCache.txt || echo "  (not set)"

            echo "Boost_FOUND:"
            grep "Boost_FOUND" build/CMakeCache.txt || echo "  (not in cache)"

            echo "Boost_VERSION:"
            grep "Boost_VERSION:" build/CMakeCache.txt || echo "  (not set)"

            echo "Boost_INCLUDE_DIRS:"
            grep "Boost_INCLUDE_DIR" build/CMakeCache.txt | head -3 || echo "  (not set)"

            echo "Boost component libraries found:"
            grep "Boost_.*_LIBRARY" build/CMakeCache.txt | head -10 || echo "  (none found)"
          else
            echo "ERROR: build/CMakeCache.txt not found"
            exit 1
          fi

          echo "=== Boost verification complete ==="

      - name: Build main application
        shell: bash
        run: |
          cmake --build build --parallel --config Release

      # =========================================================================
      # Task 4.7: Implement Installation and Deployment Steps
      # =========================================================================
      - name: Install application
        shell: bash
        run: |
          cmake --install build --config Release

      - name: Verify deployment output (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: |
          echo "=== Verifying Windows deployment ==="
          ls -la build/install/ || true
          ls -la build/install/python/ || true
          echo "Checking for executable..."
          test -f build/install/FlySightViewer.exe && echo "FlySightViewer.exe found" || echo "WARNING: FlySightViewer.exe not found"

          echo ""
          echo "=== Checking qt.conf ==="
          if [ -f "build/install/qt.conf" ]; then
            echo "qt.conf found:"
            cat build/install/qt.conf
          else
            echo "WARNING: qt.conf not found"
          fi

          echo ""
          echo "=== Checking critical DLLs ==="
          MISSING=0
          for dll in vcruntime140.dll msvcp140.dll; do
            if [ -f "build/install/$dll" ]; then
              echo "OK: $dll"
            else
              echo "ERROR: $dll MISSING"
              MISSING=1
            fi
          done
          # KDDockWidgets DLL name includes version suffix (e.g. kddockwidgets-qt62.dll)
          if ls build/install/kddockwidgets-qt6*.dll 1>/dev/null 2>&1; then
            echo "OK: KDDockWidgets DLL found"
          else
            echo "ERROR: KDDockWidgets DLL MISSING"
            MISSING=1
          fi
          # GeographicLib DLL name varies by version
          if ls build/install/Geographic*.dll 1>/dev/null 2>&1; then
            echo "OK: GeographicLib DLL found"
          else
            echo "ERROR: GeographicLib DLL MISSING"
            MISSING=1
          fi
          # vc_redist.x64.exe should NOT be present (we use app-local DLLs instead)
          if ls build/install/vc_redist*.exe 1>/dev/null 2>&1; then
            echo "WARNING: vc_redist installer found (should not be bundled)"
          fi
          if [ $MISSING -ne 0 ]; then
            echo ""
            echo "FATAL: Missing critical files in install directory"
            ls -la build/install/
            exit 1
          fi

      # =========================================================================
      # Phase 9: Comprehensive macOS RPATH Verification
      # =========================================================================
      - name: Verify deployment output (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "=== Verifying macOS deployment ==="
          BUNDLE="build/install/FlySight Viewer.app"

          echo ""
          echo "--- Bundle Structure ---"
          ls -la "$BUNDLE/Contents/" || true
          ls -la "$BUNDLE/Contents/MacOS/" || true
          ls -la "$BUNDLE/Contents/Frameworks/" | head -20 || true

          echo ""
          echo "--- Executable RPATH Verification ---"
          EXE="$BUNDLE/Contents/MacOS/FlySightViewer"
          if [ -f "$EXE" ]; then
            echo "Executable rpaths:"
            otool -l "$EXE" | grep -A2 "LC_RPATH" || echo "No LC_RPATH found"

            echo ""
            echo "Executable dependencies:"
            otool -L "$EXE" | head -20

            echo ""
            echo "Checking for absolute paths (potential issues):"
            otool -L "$EXE" | grep -v "@" | grep -v "/usr/lib" | grep -v "/System" | grep "dylib" || echo "No problematic paths found"
          else
            echo "WARNING: Executable not found"
          fi

          echo ""
          echo "--- Frameworks Library IDs ---"
          FRAMEWORKS_DIR="$BUNDLE/Contents/Frameworks"
          for dylib in "$FRAMEWORKS_DIR"/*.dylib; do
            [ -L "$dylib" ] && continue  # Skip symlinks
            [ -f "$dylib" ] || continue
            name=$(basename "$dylib")
            id=$(otool -D "$dylib" 2>/dev/null | tail -1)
            if [[ "$id" == "@rpath/"* ]]; then
              echo "OK: $name -> $id"
            else
              echo "WARN: $name -> $id (should be @rpath/...)"
            fi
          done

          echo ""
          echo "--- Checking Third-Party Libraries ---"
          for lib in libGeographic; do
            found=$(find "$FRAMEWORKS_DIR" -name "${lib}*.dylib" ! -type l 2>/dev/null | head -1)
            if [ -n "$found" ]; then
              echo "Found: $(basename "$found")"
              # Check for problematic dependencies
              bad_deps=$(otool -L "$found" | grep -v "@" | grep -v "/usr/lib" | grep -v "/System" | grep "dylib" || true)
              if [ -n "$bad_deps" ]; then
                echo "  WARNING: Has absolute paths:"
                echo "$bad_deps" | sed 's/^/    /'
              fi
            else
              echo "MISSING: ${lib}*.dylib"
            fi
          done

          echo ""
          echo "--- Checking libpython ---"
          libpython=$(find "$FRAMEWORKS_DIR" -name "libpython*.dylib" ! -type l 2>/dev/null | head -1)
          if [ -n "$libpython" ]; then
            echo "Found: $(basename "$libpython")"
            echo "ID: $(otool -D "$libpython" | tail -1)"
          else
            echo "MISSING: libpython*.dylib"
          fi

          echo ""
          echo "--- Checking pybind11 Module ---"
          bridge=$(find "$BUNDLE" -name "flysight_cpp_bridge*.so" 2>/dev/null | head -1)
          if [ -n "$bridge" ]; then
            echo "Found: $bridge"
            echo "Dependencies:"
            otool -L "$bridge" | head -10
            echo "RPaths:"
            otool -l "$bridge" | grep -A2 "LC_RPATH" || echo "No LC_RPATH"
          else
            echo "MISSING: flysight_cpp_bridge module"
          fi

          echo ""
          echo "--- Checking qt.conf ---"
          if [ -f "$BUNDLE/Contents/Resources/qt.conf" ]; then
            echo "qt.conf found:"
            cat "$BUNDLE/Contents/Resources/qt.conf"
          else
            echo "WARNING: qt.conf not found"
          fi

          echo ""
          echo "=== macOS Verification Complete ==="

      - name: Verify code signing (macOS)
        if: runner.os == 'macOS'
        run: |
          BUNDLE="build/install/FlySight Viewer.app"

          echo "=== Code Signing Verification ==="

          # Check signing status
          codesign --verify --deep --strict --verbose=2 "$BUNDLE" 2>&1 || true

          # Display signing info
          echo ""
          echo "--- Signing Info ---"
          codesign --display --verbose=4 "$BUNDLE" 2>&1 | head -20

          # Check entitlements on the main executable
          echo ""
          echo "--- Entitlements ---"
          codesign --display --entitlements - "$BUNDLE" 2>&1 || true

          # Check QtWebEngineProcess signing
          QTWE_HELPER="$BUNDLE/Contents/Frameworks/QtWebEngineCore.framework/Versions/A/Helpers/QtWebEngineProcess.app"
          if [ -d "$QTWE_HELPER" ]; then
            echo ""
            echo "--- QtWebEngineProcess Signing ---"
            codesign --display --entitlements - "$QTWE_HELPER" 2>&1 || true
          fi

          # Verify distribution signature strictly
          if [ "$FLYSIGHT_CODESIGN_IDENTITY" != "-" ] && [ -n "$FLYSIGHT_CODESIGN_IDENTITY" ]; then
            echo ""
            echo "--- Verifying distribution signature ---"
            if codesign --verify --deep --strict "$BUNDLE" 2>&1; then
              echo "Distribution signature: VALID"
            else
              echo "ERROR: Distribution signature verification FAILED"
              exit 1
            fi
          fi

          echo ""
          echo "=== Code Signing Verification Complete ==="

      - name: Verify deployment output (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "=== Verifying Linux deployment ==="
          APPDIR="build/install/FlySightViewer.AppDir"

          # Check AppDir structure
          echo "--- AppDir Structure ---"
          for dir in usr/bin usr/lib usr/plugins usr/qml usr/share/python; do
            if [ -d "$APPDIR/$dir" ]; then
              echo "  $dir: OK ($(ls -1 "$APPDIR/$dir" 2>/dev/null | wc -l) items)"
            else
              echo "  $dir: MISSING"
            fi
          done

          echo ""
          echo "--- AppRun and Desktop Files ---"
          test -x "$APPDIR/AppRun" && echo "  AppRun: OK (executable)" || echo "  AppRun: MISSING or not executable"
          test -f "$APPDIR/FlySightViewer.desktop" && echo "  Desktop file: OK" || echo "  Desktop file: MISSING"
          test -f "$APPDIR/FlySightViewer.png" && echo "  Icon: OK" || echo "  Icon: MISSING"

          echo ""
          echo "--- Third-Party Libraries ---"
          for lib in libGeographic libkddockwidgets; do
            found=$(find "$APPDIR/usr/lib" -name "${lib}*.so*" 2>/dev/null | head -1)
            if [ -n "$found" ]; then
              echo "  $lib: $(basename $found)"
            else
              echo "  $lib: NOT FOUND"
            fi
          done

          echo ""
          echo "--- Qt Components ---"
          if [ -d "$APPDIR/usr/plugins/platforms" ]; then
            echo "  Platform plugins: $(ls "$APPDIR/usr/plugins/platforms/" 2>/dev/null)"
          else
            echo "  Platform plugins: MISSING"
          fi
          test -f "$APPDIR/usr/bin/qt.conf" && echo "  qt.conf: OK" || echo "  qt.conf: MISSING"

          echo ""
          echo "--- Python Bundle ---"
          PYTHON_DIR="$APPDIR/usr/share/python"
          if [ -d "$PYTHON_DIR" ]; then
            echo "  Python directory: OK"
            PYTHON_BIN="$PYTHON_DIR/bin/python3"
            if [ -x "$PYTHON_BIN" ]; then
              echo "  Python version: $("$PYTHON_BIN" --version 2>&1)"
            else
              echo "  Python executable: MISSING"
            fi

            # Check for bridge module
            BRIDGE=$(find "$PYTHON_DIR" -name "flysight_cpp_bridge*.so" 2>/dev/null | head -1)
            if [ -n "$BRIDGE" ]; then
              echo "  Bridge module: $(basename $BRIDGE)"
              # Verify RPATH
              RPATH=$(patchelf --print-rpath "$BRIDGE" 2>/dev/null)
              echo "  Bridge RPATH: $RPATH"
            else
              echo "  Bridge module: NOT FOUND"
            fi
          else
            echo "  Python bundle: MISSING"
          fi

          echo ""
          echo "--- Executable RPATH ---"
          EXE="$APPDIR/usr/bin/flysight-viewer"
          if [ -f "$EXE" ]; then
            RPATH=$(patchelf --print-rpath "$EXE" 2>/dev/null)
            echo "  flysight-viewer RPATH: $RPATH"
          fi

          echo ""
          echo "=== Verification Complete ==="

      # =========================================================================
      # Task 4.7: Linux AppImage Creation
      # =========================================================================
      - name: Create AppImage (Linux)
        if: runner.os == 'Linux'
        env:
          APPIMAGE_EXTRACT_AND_RUN: 1
        run: |
          echo "=== Creating AppImage ==="

          # Run the appimage target if available, otherwise create manually
          if cmake --build build --target appimage 2>/dev/null; then
            echo "AppImage created via CMake target"
          else
            echo "Creating AppImage manually..."

            # Download appimagetool
            APPIMAGETOOL_URL="https://github.com/AppImage/appimagetool/releases/download/continuous/appimagetool-x86_64.AppImage"
            wget -q -O appimagetool "$APPIMAGETOOL_URL"
            chmod +x appimagetool

            # Create AppImage
            APPDIR="build/install/FlySightViewer.AppDir"
            if [ -d "$APPDIR" ]; then
              ./appimagetool "$APPDIR" "FlySightViewer-${FLYSIGHT_VERSION_DISPLAY}-Linux-${{ matrix.arch }}.AppImage"
              mv "FlySightViewer-${FLYSIGHT_VERSION_DISPLAY}-Linux-${{ matrix.arch }}.AppImage" build/
            else
              echo "ERROR: AppDir not found at $APPDIR"
              exit 1
            fi
          fi

          echo "AppImage creation complete"
          ls -la build/*.AppImage || true

      - name: Verify AppImage (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "=== Verifying AppImage ==="

          APPIMAGE=$(find build -name "*.AppImage" -type f 2>/dev/null | head -1)
          if [ -z "$APPIMAGE" ]; then
            echo "WARNING: No AppImage found in build/"
            ls -la build/
            exit 0
          fi

          echo "AppImage: $APPIMAGE"
          echo "Size: $(ls -lh "$APPIMAGE" | awk '{print $5}')"

          # Test extraction (doesn't require FUSE)
          echo ""
          echo "--- Testing AppImage extraction ---"
          export APPIMAGE_EXTRACT_AND_RUN=1

          # Extract to temporary directory
          EXTRACT_DIR=$(mktemp -d)
          cd "$EXTRACT_DIR"
          "$GITHUB_WORKSPACE/$APPIMAGE" --appimage-extract >/dev/null 2>&1

          if [ -d "squashfs-root" ]; then
            echo "Extraction: OK"
            echo "Contents:"
            ls -la squashfs-root/

            # Quick sanity check
            echo ""
            echo "--- Sanity checks ---"
            test -x squashfs-root/AppRun && echo "AppRun: OK" || echo "AppRun: FAILED"
            test -x squashfs-root/usr/bin/flysight-viewer && echo "Executable: OK" || echo "Executable: FAILED"
            test -f squashfs-root/usr/bin/qt.conf && echo "qt.conf: OK" || echo "qt.conf: MISSING"

            # Check RPATH in extracted files
            echo ""
            echo "--- RPATH verification ---"
            if [ -f squashfs-root/usr/bin/flysight-viewer ]; then
              RPATH=$(patchelf --print-rpath squashfs-root/usr/bin/flysight-viewer 2>/dev/null)
              echo "flysight-viewer RPATH: $RPATH"
            fi

            BRIDGE=$(find squashfs-root/usr/share/python -name "flysight_cpp_bridge*.so" 2>/dev/null | head -1)
            if [ -n "$BRIDGE" ]; then
              BRIDGE_RPATH=$(patchelf --print-rpath "$BRIDGE" 2>/dev/null)
              echo "Bridge module RPATH: $BRIDGE_RPATH"
            fi
          else
            echo "Extraction: FAILED"
          fi

          # Cleanup
          cd "$GITHUB_WORKSPACE"
          rm -rf "$EXTRACT_DIR"

          echo ""
          echo "=== AppImage Verification Complete ==="

      # =========================================================================
      # Task 4.8: Implement Artifact Packaging
      # =========================================================================
      - name: Package with CPack (macOS)
        if: runner.os == 'macOS'
        working-directory: build
        run: |
          cpack -G DragNDrop -C Release
          echo "=== CPack output ==="
          ls -la *.dmg || true

      # =========================================================================
      # macOS App Notarization: Notarize the .app from CPack's staging dir,
      # then rebuild the DMG so it contains the stapled .app.
      # (CPack re-runs cmake --install into a fresh staging directory, so any
      # ticket stapled before CPack is lost. We must notarize after CPack.)
      # =========================================================================
      - name: Notarize app and rebuild DMG (macOS)
        if: >-
          runner.os == 'macOS'
          && startsWith(github.ref, 'refs/tags/v')
          && env.FLYSIGHT_CODESIGN_IDENTITY != '-'
          && env.FLYSIGHT_CODESIGN_IDENTITY != ''
        env:
          MACOS_NOTARIZATION_APPLE_ID: ${{ secrets.MACOS_NOTARIZATION_APPLE_ID }}
          MACOS_NOTARIZATION_PASSWORD: ${{ secrets.MACOS_NOTARIZATION_PASSWORD }}
          MACOS_NOTARIZATION_TEAM_ID: ${{ secrets.MACOS_NOTARIZATION_TEAM_ID }}
        shell: bash
        run: |
          set -euo pipefail

          # Find the .app in CPack's staging directory
          APP_BUNDLE=$(find build/_CPack_Packages -name "*.app" -type d -maxdepth 4 | head -1)
          if [ -z "$APP_BUNDLE" ]; then
            echo "ERROR: No .app found in CPack staging directory"
            exit 1
          fi
          STAGING_DIR=$(dirname "$APP_BUNDLE")

          echo "=== Notarizing app bundle ==="
          echo "App bundle: $APP_BUNDLE"
          echo "Staging dir: $STAGING_DIR"

          # Create zip for notarization submission (ditto required by Apple)
          APP_ZIP="$RUNNER_TEMP/FlySightViewer-app.zip"
          echo ""
          echo "--- Creating submission archive ---"
          ditto -c -k --keepParent "$APP_BUNDLE" "$APP_ZIP"
          echo "Archive size: $(ls -lh "$APP_ZIP" | awk '{print $5}')"

          # Submit to Apple's notary service
          echo ""
          echo "--- Submitting to notary service ---"
          xcrun notarytool submit "$APP_ZIP" \
            --apple-id "$MACOS_NOTARIZATION_APPLE_ID" \
            --password "$MACOS_NOTARIZATION_PASSWORD" \
            --team-id "$MACOS_NOTARIZATION_TEAM_ID" \
            --wait \
            --timeout 30m

          # Staple the notarization ticket to the .app
          echo ""
          echo "--- Stapling notarization ticket ---"
          xcrun stapler staple "$APP_BUNDLE"

          # Validate
          echo ""
          echo "--- Validating stapled ticket ---"
          xcrun stapler validate "$APP_BUNDLE"
          spctl --assess --type execute --verbose=4 "$APP_BUNDLE"

          # Clean up zip
          rm -f "$APP_ZIP"

          # Rebuild DMG from staging directory so it contains the stapled .app
          DMG=$(find build -maxdepth 1 -name "*.dmg" | head -1)
          if [ -z "$DMG" ]; then
            echo "ERROR: No DMG found to replace"
            exit 1
          fi

          echo ""
          echo "--- Rebuilding DMG with stapled app ---"
          rm -f "$DMG"
          hdiutil create \
            -volname "FlySight Viewer ${FLYSIGHT_VERSION_DISPLAY}" \
            -srcfolder "$STAGING_DIR" \
            -ov -format UDZO \
            "$DMG"
          echo "DMG rebuilt: $DMG ($(ls -lh "$DMG" | awk '{print $5}'))"

          echo ""
          echo "=== App bundle notarization complete ==="

      - name: Sign DMG (macOS)
        if: runner.os == 'macOS' && env.FLYSIGHT_CODESIGN_IDENTITY != '-' && env.FLYSIGHT_CODESIGN_IDENTITY != ''
        run: |
          DMG=$(find build -maxdepth 1 -name "*.dmg" | head -1)
          if [ -n "$DMG" ]; then
            echo "Signing DMG: $DMG"
            codesign --force --sign "$FLYSIGHT_CODESIGN_IDENTITY" --timestamp "$DMG"
            codesign --verify --verbose "$DMG"
            echo "DMG signed successfully"
          else
            echo "WARNING: No DMG found to sign"
          fi

      - name: Notarize DMG (macOS)
        if: >-
          runner.os == 'macOS'
          && startsWith(github.ref, 'refs/tags/v')
          && env.FLYSIGHT_CODESIGN_IDENTITY != '-'
          && env.FLYSIGHT_CODESIGN_IDENTITY != ''
        env:
          MACOS_NOTARIZATION_APPLE_ID: ${{ secrets.MACOS_NOTARIZATION_APPLE_ID }}
          MACOS_NOTARIZATION_PASSWORD: ${{ secrets.MACOS_NOTARIZATION_PASSWORD }}
          MACOS_NOTARIZATION_TEAM_ID: ${{ secrets.MACOS_NOTARIZATION_TEAM_ID }}
        run: |
          DMG=$(find build -maxdepth 1 -name "*.dmg" | head -1)
          if [ -z "$DMG" ]; then
            echo "ERROR: No DMG found for notarization"
            exit 1
          fi

          echo "=== Submitting DMG for notarization ==="
          echo "DMG: $DMG"

          # Submit to Apple's notary service
          xcrun notarytool submit "$DMG" \
            --apple-id "$MACOS_NOTARIZATION_APPLE_ID" \
            --password "$MACOS_NOTARIZATION_PASSWORD" \
            --team-id "$MACOS_NOTARIZATION_TEAM_ID" \
            --wait \
            --timeout 30m

          echo ""
          echo "=== Stapling notarization ticket ==="
          xcrun stapler staple "$DMG"

          echo ""
          echo "=== Verifying notarization ==="
          xcrun stapler validate "$DMG"
          spctl --assess --type open --context context:primary-signature --verbose=2 "$DMG" || true

          echo ""
          echo "=== Notarization complete ==="

      # =========================================================================
      # macOS Gatekeeper Smoke Test: Verify end-to-end notarization
      # =========================================================================
      - name: Gatekeeper smoke test (macOS)
        if: >-
          runner.os == 'macOS'
          && startsWith(github.ref, 'refs/tags/v')
          && env.FLYSIGHT_CODESIGN_IDENTITY != '-'
          && env.FLYSIGHT_CODESIGN_IDENTITY != ''
        shell: bash
        run: |
          set -euo pipefail

          echo "=== Gatekeeper Smoke Test ==="
          echo "Simulates: download DMG -> copy .app to Applications -> launch"

          # Find the DMG
          DMG=$(find build -maxdepth 1 -name "*.dmg" | head -1)
          if [ -z "$DMG" ]; then
            echo "ERROR: No DMG found for smoke test"
            exit 1
          fi
          echo "DMG: $DMG"

          # Set up temp directories
          SMOKE_DIR="$RUNNER_TEMP/gatekeeper-smoke-test"
          MOUNT_POINT="$SMOKE_DIR/dmg-mount"
          mkdir -p "$MOUNT_POINT"

          # Mount DMG
          echo ""
          echo "--- Mounting DMG ---"
          hdiutil attach "$DMG" -readonly -mountpoint "$MOUNT_POINT" -nobrowse

          # Copy .app out (simulates user dragging to /Applications)
          echo ""
          echo "--- Extracting .app from DMG ---"
          APP_SRC=$(find "$MOUNT_POINT" -maxdepth 1 -name "*.app" -type d | head -1)
          if [ -z "$APP_SRC" ]; then
            echo "ERROR: No .app found in mounted DMG"
            hdiutil detach "$MOUNT_POINT" -force || true
            exit 1
          fi
          APP_NAME=$(basename "$APP_SRC")
          ditto "$APP_SRC" "$SMOKE_DIR/$APP_NAME"

          # Detach DMG
          hdiutil detach "$MOUNT_POINT" -force

          # Add quarantine attribute (simulates browser download)
          echo ""
          echo "--- Adding quarantine attribute ---"
          xattr -w com.apple.quarantine \
            "0083;$(printf '%x' "$(date +%s)");Safari;$(uuidgen)" \
            "$SMOKE_DIR/$APP_NAME"

          # Gatekeeper assessment
          echo ""
          echo "--- Gatekeeper assessment (spctl --type execute) ---"
          spctl --assess --type execute --verbose=4 "$SMOKE_DIR/$APP_NAME"
          echo "PASSED: Gatekeeper accepts the app"

          # Verify stapled ticket survived DMG round-trip
          echo ""
          echo "--- Verifying stapled notarization ticket ---"
          xcrun stapler validate "$SMOKE_DIR/$APP_NAME"
          echo "PASSED: Stapled ticket is present"

          # Clean up
          rm -rf "$SMOKE_DIR"

          echo ""
          echo "=== Gatekeeper Smoke Test PASSED ==="

      # =========================================================================
      # Task 4.8: Collect Artifacts
      # =========================================================================
      - name: Collect artifacts
        shell: bash
        run: |
          mkdir -p artifacts

          if [ "${{ runner.os }}" == "Windows" ]; then
            # Create a ZIP with FlySightViewer/ as the top-level folder
            cp -r build/install artifacts/FlySightViewer
            cd artifacts
            7z a -r "FlySightViewer-${FLYSIGHT_VERSION_DISPLAY}-Windows-${{ matrix.arch }}.zip" FlySightViewer/
            rm -rf FlySightViewer
            cd ..
          elif [ "${{ runner.os }}" == "macOS" ]; then
            cp build/*.dmg artifacts/ 2>/dev/null || true
            # Fallback: create dmg manually if CPack didn't work
            if [ ! -f artifacts/*.dmg ]; then
              hdiutil create -volname "FlySight Viewer ${FLYSIGHT_VERSION_DISPLAY}" -srcfolder "build/install/FlySight Viewer.app" -ov -format UDZO artifacts/FlySightViewer-${FLYSIGHT_VERSION_DISPLAY}-${{ matrix.platform }}-${{ matrix.arch }}.dmg 2>/dev/null || true
            fi
          elif [ "${{ runner.os }}" == "Linux" ]; then
            cp build/*.AppImage artifacts/ 2>/dev/null || true
          fi

          echo "=== Collected artifacts ==="
          ls -la artifacts/

      # =========================================================================
      # Task 4.9: Implement Artifact Upload
      # =========================================================================
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: FlySightViewer-${{ matrix.platform }}-${{ matrix.arch }}
          path: artifacts/*
          retention-days: 30
          if-no-files-found: warn

      # =========================================================================
      # macOS Code Signing: Cleanup
      # =========================================================================
      - name: Cleanup keychain (macOS)
        if: always() && runner.os == 'macOS' && env.KEYCHAIN_PATH != ''
        run: |
          echo "Cleaning up signing keychain..."
          security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
          echo "Keychain cleanup complete"

  # ===========================================================================
  # Task 4.10: Release Publishing Job
  # ===========================================================================
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Download release artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: "FlySightViewer-*"
          path: release-artifacts
          merge-multiple: true

      - name: List downloaded artifacts
        run: |
          echo "=== Downloaded artifacts ==="
          find release-artifacts -type f -ls

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          draft: true
          generate_release_notes: true
          files: |
            release-artifacts/*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
